{"./":{"url":"./","title":"Sudal's Note","keywords":"","body":"Sudal's Note CLI # Build $ gitbook install # Local Server $ gitbook serve # Remote Static Publish ./publish_gitbook.sh Tip 맥 백쿼트(`) 만들기 스크립트 실행 $ if ! [ -f ~/Library/KeyBindings/DefaultkeyBinding.dict ]; then mkdir -p ~/Library/KeyBindings && echo '{\"₩\" = (\"insertText:\", \"\\`\");}' > ~/Library/KeyBindings/DefaultkeyBinding.dict; fi 어플리케이션 재 실행 (재부팅) Statement 제목 분류 중분류 내용내용내용 Syntax public void main (String[] args) { } Parameter args 매개변수 Example #1 : Java public void main (String[] args) { } Example #2 : JS - ES5 function foo() { } Example #2 : JS - ES6 var foo = () => { }; callouts Info: Infodescription Note: Note Tag: Tag Comment: Comment Hint: Hint Success: Success Warning: Warning Caution: Caution Danger: Danger Quote: Quote mermaid graph TD; A-->B; A-->C; B-->D; C-->D; sequenceDiagram participant Alice participant Bob Alice->John: Hello John, how are you? loop Healthcheck John->John: Fight against hypochondria end Note right of John: Rational thoughts prevail... John-->Alice: Great! John->Bob: How about you? Bob-->John: Jolly good! gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d sequenceDiagram Alice ->> Bob: Hello Bob, how are you? Bob-->>John: How about you John? Bob--x Alice: I am good thanks! Bob-x John: I am good thanks! Note right of John: Bob thinks a longlong time, so longthat the text doesnot fit on a row. Bob-->Alice: Checking with John... Alice->John: Yes... John, how are you? graph LR A[Square Rect] -- Link text --> B((Circle)) A --> C(Round Rect) B --> D{Rhombus} C --> D graph TB sq[Square shape] --> ci((Circle shape)) subgraph A subgraph od>Odd shape]-- Two lineedge comment --> ro di{Diamond with line break} -.-> ro(Roundedsquareshape) di==>ro2(Rounded square shape) end %% Notice that no text in shape are added here instead that is appended further down e --> od3>Really long text with linebreakin an Odd shape] %% Comments after double percent signs e((Inner / circleand some odd special characters)) --> f(,.?!+-*ز) cyr[Cyrillic]-->cyr2((Circle shape Начало)); classDef green fill:#9f6,stroke:#333,stroke-width:2px; classDef orange fill:#f96,stroke:#333,stroke-width:4px; class sq,e green class di orange sequenceDiagram loop Daily query Alice->>Bob: Hello Bob, how are you? alt is sick Bob->>Alice: Not so good :( else is well Bob->>Alice: Feeling fresh like a daisy end opt Extra response Bob->>Alice: Thanks for asking end end sequenceDiagram participant Alice participant Bob Alice->>John: Hello John, how are you? loop Healthcheck John->>John: Fight against hypochondria end Note right of John: Rational thoughtsprevail... John-->>Alice: Great! John->>Bob: How about you? Bob-->>John: Jolly good! Reference Url https://mermaidjs.github.io/ "},"01.-general/":{"url":"01.-general/","title":"01. General","keywords":"","body":"01. General 문 과 식 의 차이 문 코드 엔진에서 해석하고 버리는 힌트 같은 것 (Java, Javascript, C, ... ) 식 변수에 할당되어 저장 된다 (Ruby, Kotlin, ... ) RBAC (Role Based Access Control : 역활기반 접근 통제) 접근하려는 사용자와 자원이 어떻게 상호작용하는지 결정하여 중앙에서 집중적으로 작용한다. 역할 할당 (Role Assignment) 역할 권한 부여 (Role Authorization) 권한 부여 (Permission Authorization) MAC (Mandatory Access Control : 강제적 접근 통제) DAC (Discretionary Access Control : 임의적 접근 통제) "},"01.-general/ide.html":{"url":"01.-general/ide.html","title":"IDE","keywords":"","body":"IDE VSCode extension package BreadCrumb in StatusBar 선택 파일 경로 노출 GitLens 선택 행 깃 커밋 보여주기 One Dark Pro 에디터 테마 vscode-icons 에디터 아이콘 Material Icon Theme 에디터 아이콘 usersetting.json { \"workbench.startupEditor\": \"welcomePage\", \"gitlens.advanced.messages\": { \"suppressCommitHasNoPreviousCommitWarning\": false, \"suppressCommitNotFoundWarning\": false, \"suppressFileNotUnderSourceControlWarning\": false, \"suppressGitVersionWarning\": false, \"suppressLineUncommittedWarning\": false, \"suppressNoRepositoryWarning\": false, \"suppressResultsExplorerNotice\": false, \"suppressShowKeyBindingsNotice\": true, \"suppressUpdateNotice\": false, \"suppressWelcomeNotice\": true }, \"window.zoomLevel\": 0, \"editor.tabSize\": 2, \"editor.fontFamily\": \"D2Coding ligature\", \"editor.fontLigatures\": true, \"editor.fontSize\": 14, \"gitlens.keymap\": \"alternate\", \"gitlens.historyExplorer.enabled\": true, \"workbench.colorTheme\": \"One Dark Pro Vivid\", \"breadcrumbs.enabled\": true // 필요할때 사용 // \"eslint.options\": { // \"configFile\": \"/Users/rrest/wemakeprice/workspace/.eslintrc\" // } } .eslintrc { \"env\": { \"jquery\": true, \"browser\": true, \"amd\": true, \"commonjs\": true, \"es6\": true }, \"parser\": \"babel-eslint\", \"parserOptions\": { \"ecmaVersion\": 6, \"sourceType\": \"module\", \"ecmaFeatures\": { \"jsx\": true } }, \"globals\": { \"alert\": false, \"clearTimeout\": false, \"clearInterval\": false, \"document\": false, \"exports\": false, \"module\": false, \"navigator\": false, \"require\": false, \"setInterval\": false, \"setTimeout\": false, \"window\": false, \"XMLHttpRequest\": false }, \"rules\": { \"camelcase\": [\"error\", {\"properties\": \"always\"}], \"comma-spacing\": [\"error\", {\"before\": false, \"after\": true}], \"comma-style\": [\"error\", \"last\"], \"comma-dangle\": \"error\", \"brace-style\": [\"error\", \"1tbs\", { \"allowSingleLine\": true }], \"indent\": [\"error\", 2, { \"SwitchCase\": 1 }], \"valid-jsdoc\": [\"warn\", {\"requireReturn\":false}], \"block-scoped-var\": \"warn\", \"curly\": \"error\", \"eqeqeq\": \"warn\", \"quotes\": [\"error\", \"single\"], \"semi\": \"error\", \"no-inline-comments\": \"warn\", \"no-debugger\": \"error\", \"no-console\": \"warn\", \"no-empty\": \"warn\", \"no-spaced-func\": \"warn\", \"no-array-constructor\": \"error\", \"no-undefined\": \"warn\", \"no-alert\": \"off\", \"no-loop-func\": \"error\", \"no-multi-spaces\": \"error\", \"no-new\": \"error\", \"no-unused-expressions\": \"error\", \"no-unused-vars\": \"warn\", \"no-use-before-define\": [\"error\", {\"functions\": false}], \"space-before-blocks\": \"error\", \"semi-spacing\": [\"error\", {\"before\": false, \"after\": true}], \"keyword-spacing\": [\"error\", {\"before\": true, \"after\": true}], \"no-new-object\": \"error\", \"key-spacing\": [\"error\", {\"beforeColon\": false, \"afterColon\": true}], \"space-infix-ops\": [\"error\"], \"space-before-function-paren\": [\"error\", {\"anonymous\": \"always\", \"named\": \"never\"}] } } "},"01.-general/algorithm/":{"url":"01.-general/algorithm/","title":"Algorithm","keywords":"","body":"Algorithm "},"01.-general/algorithm/sort.html":{"url":"01.-general/algorithm/sort.html","title":"Sort","keywords":"","body":"Sort 퀵 정렬 (Quick Sort) 정렬중에서 가장 빠른 정렬로 보통 시간 복잡도은 O(n log n) 이며 최악의경우 O(n²) 으로 시간복잡도가 소요된다. 머지 정렬 (Merge Sort) 정렬하려는 배열을 반으로 나눠 최소의 파티션으로 나누고 정렬한 후 머지하면서 정렬 시간 복잡도는 O(n log n) 으로 퀵 정렬과 달리 별도의 저장공간이 필요 하다. Example # 1 : JS - ES5 var arr = [6, 3, 8, 4, 1, 9, 2, 5, 7, 0]; function MergeSort(arr) { this.arr = null; if (arr instanceof Array) { this.arr = arr; return this.sort(arr); } } MergeSort.prototype = (function () { function sort(arr) { if (typeof arr === 'undefined' || !(arr instanceof Array)) { if (!(this.arr instanceof Array)) { throw new Error('Array object is not exist'); } arr = this.arr; } if (arr.length === 1) { return arr; } var mid = Math.floor(arr.length / 2), left = arr.slice(0, mid), right = arr.slice(mid); return merge(sort(left), sort(right)); } function merge(left, right) { var answer = [], leftLength = left.length, rightLength = right.length, leftIdx = 0, rightIdx = 0; while (leftIdx console.log(new MergeSort(arr)); var ms = new MergeSort(); console.log(ms.sort(arr)); 버블 (Bubble) 왼쪽 끝에서 부터 인접하는 두 항목의 값을 비교하여 서로 위치를 교환하는 정렬 방법 선택 (Selection) 전체 요소에서 기준 위치에 맞는 원소를 선택하여 교환하는 방식 삽입 (Insertion) 전체요소에서 가장 작은 데이터를 찾아 가장 앞의 데이터와 교환하는 방식 속도 비교 퀵 > 합병 > 힙 > 쉘 > 삽입 > 선택 > 버블 "},"02.-front-end/":{"url":"02.-front-end/","title":"02. Front End","keywords":"","body":"02. Front End SPA 환경의 뒤로가기 기존의 페이지 이동을 통한 뒤로가기 URL 을 직접적으로 조작하여 페이지를 이동하는 방식 앵커를 이용한 방식 앵커를 이용한 방식은 서버로 전달되지 않기 때문에 프론트에서 제어가 가능하다. 이후에 해시뱅 (#!) 이라는 기법을 통하여 URL 과 유사하게 포장했다. 해시뱅은 다음과 같은 치명적인 단점 이 있다. 자바스크립트가 동작하지 않으면 사이트 전체가 동작하지 않기 때문에 자바스크립트 로딩 & 파싱이 정상적으로 완료 해야 한다. 크롤링의 제한 브라우저 캐시를 정상적으로 사용불가 네트워크 중개서버가 핸들링이 안되기 때문에 모든 트래픽을 다루어야 한다. pushState 를 이용한 방식 HTML5 에 새로 추가된 History API 의 한 방식으로 IE 10 이상에서 사용 가능한 방식이다.브라우저의 히스토리를 조작 하여 사용하는 방식 Reference https://blog.outsider.ne.kr/1276 "},"02.-front-end/01.-html/":{"url":"02.-front-end/01.-html/","title":"01. HTML","keywords":"","body":"01. HTML DTD (Document Type Definition) HTML 에서 문서 형식을 지정하는 것을 DTD 라고 하며 DTD 는 HTML 문서에 첫번째 줄에 위치해야 한다. 문서형식은 HTML 버전과 종류를 명시함으로써, 브라우저가 문서를 해석하고 출력하는데 직접적으로 영향 을 준다. 올바르게 문서형식이 지정된 경우에는 표준 (Strict) 방식, 그렇지 않는 경우에는 호환 (Quirks) 방식으로 출력한다. 호환 출력 방식 (Quirks Rendering Mode) 특징 브라우저가 HTML 을 랜더링 (읽기, 해석, 출력) 하는 시간이 더 걸린다. 브라우저마다 HTML 출력을 각각 다르게 출력한다. Example #1 : HTML onload object 가 로드 되었을 때 발생 합니다.웹 페이지가 모든 컨텐츠 (이미지, 스크립트 파일, 스타일시트) 등을 완전히 로드한 후 실행 합니다. Syntax object.onload = function () {/* script */}; object.addEventListener('load', script); Detail Feature Description 이벤트 버블링 NO 중단 가능 여부 NO 이벤트 유형 UI 생성시 지원 태그 , , , , , , , DOM 버전 Level 2 이벤트 시맨틱 (Semantic) 마크업 브라우저가 웹 문서 (HTML) 를 정확히 읽어내기 위하여 정보의 의미에 맞는 HTML Tag 를 이용하여 작성하는 것출력 형태는 와 별 차이는 없다. 장점 웹 접근성이 좋아짐 SEO (Search Engine Optimization) 개선 효과 코드 가독성, 재사용성이 높아짐 대표적으로 가 있다. 태그 설명 section 문서의 구획 (예: 장, 절) article 독립된 콘텐츠 영역 (예: 개별 신문기사) nav 네비게이션 메뉴 영역 aside 부가 콘텐츠(예: 사이드바, 광고 등) 본문 내용과 비교적 관련성이 적은 것 header 헤더글. 본문 위에 첨가하는 짧은 글 영역 footer 바닥글. 본문 아래에 첨가하는 짧은 글 영역 hgroup 제목(h1 ~ h6) 을 그룹화하는 요소 "},"02.-front-end/01.-html/performance.html":{"url":"02.-front-end/01.-html/performance.html","title":"Performance","keywords":"","body":"Performance HTML 속도 개선을 위해서는 기본적인 먼저 랜더링 순서를 파악하고 이를 개선해야 한다. HTML 랜더링 순서 graph LR A[HTML] -- HTML Parse --> B[DOM Tree] B --> C[Render Tree] D[CSS] -- CSS Parse --> E[CSS Object Model] E --> C C --> F[Reflow] F --> G[Repaint] 사용자가 브라우저에 URL을 입력하거나 이동을 한다. 브라우저 인터페이스 엔진에서 해당 작업을 분석 한다. 페이지 이동이 확인되면 해당 서버에 정보를 요청 한다. 도메인의 경우 DNS Lookup 을 통하여 서버 IP 경로를 얻어온다. 얻어온 서버 경로로 필요한 경로 정보를 요청 한다. (3 Way Handshake) HTTP 요청 응답이 MIME 타입을 확인하여 해당 자원을 다운로드 한다. 다운로드 된 HTML 및 CSS 문서를 해석하는 과정을 거친다 HTML 을 해석하여 DOM Tree 구성을 한다. CSS 를 해석하여 CSSOM (Cascading Style Sheets Object Model) 을 구성한다. 위 두 구성이 모두 완료 하여야만 다음 진행이 가능하다. (CSS : 랜더링 블라킹 요소) 이후 자바스크립트 태그 혹은 구문을 만나면 약속된 프로세스 (비차단 스크립트) 대로 진행 한다. DOM Tree & CSSOM 이 완료 되면 Render Tree 구성을 진행한다. CSS 규칙중 {display:none} 을 만나면 Render Tree 구성에서는 빠진다. (DOM Tree 에는 존재) Render Tree 구성이 완료되면 Reflow 작업을 통하여 필요한 레이아웃을 화면에 배치한다. Reflow 작업이 완료 되면 Repaint 과정을 통하여 화면에 배치한 레이아웃을 그린다. HTML 개선 방안 HTML 랜더링 속도를 올리는 방법에는 다음과 같은 방법이 있다. HTTP Request 최소화 서버에 자원의 요청을 최소화 하는 방법으로 네트워크 레이턴시를 줄여 성능을 개선한다. Resource 압축 정적 리소스 (HTML, JS, CSS) 의 소스를 압축 (manifest) 하여 제공하는데JS, CSS 는 모듈 번들러 (webpack, manifest ... ) 를 통하여 제공하고HTML 은 gzip 전송을 한다. Reflow, Repaint 최소화 추가적으로 브라우저에서 Reflow 를 일으킬만한 요소들을 최소화 하기 위하여 다음 가이드라인을 참고한다. 사용자의 브라우저 별로 리플루우 (Reflow) 가 걸리는 시간도 상이 하지만 대부분의 리플로우를 일으키는 조건은 동일하여 아래의 가이드라인을 통하여 충분히 개선이 가능하다. 불필요한 DOM Depth를 줄인다. DOM Tree 의 Depth 하나를 변경하면 트리의 모든 Depth 에 따라 더 많은 시간이 소요된다. 부모로는 Root, 자식은 Update 된 Node 까지 변경 될 가능성이 있음 CSS 규칙을 최소화 하고 사용하지 않는 CSS 규칙을 삭제한다. 애니메이션과 같이 복잡한 랜더링 요소는 흐름의 밖에서 변경한다. 변경시에는 절대 위치 혹은 고정 위치를 사용한다. 불필요하거나 복잡한 CSS 선택기 하위요소 선택기를 사용하지 않는다. 선택기와 일치시키기 위해서 더 높은 GPU 처리량의 필요가 요구된다. 그 외 방법들 이미지 최적화 큰 이미지를 CSS 로 잘라서 사용 BASE 64 Encoding 전송 브라우저 캐싱 사용 방문 리다이렉션 사용 안함 Reference https://developers.google.com/speed/docs/insights/browser-reflow?hl=kohttp://lists.w3.org/Archives/Public/public-html-ig-ko/2011Sep/att-0030/Reflow_____________________________Tip.pdfhttp://www.stubbornella.org/content/2009/03/27/reflows-repaints-css-performance-making-your-javascript-slow/ "},"02.-front-end/02.-css.html":{"url":"02.-front-end/02.-css.html","title":"02. CSS","keywords":"","body":"02. CSS 스타일 태그 위치 태그에 위치 시켜야 한다. 하단에 위치 시키게 되면 HTML 파일을 두 번 읽어서 적용 시키기 때문 inline & inline block {display: inline;} 대표적으로는 태그의 성질로 content/text 크기만큼만 점유하고 동일 라인에 붙는 성질이다. width height 적용 불가 margin padding-top padding-bottom 적용 불가 line-height 원하는대로 적용 불가 ( 에 적용 안되고 감싸고 있는 전체 크기에만 영향을 줌) {display: block;} 무조건 한줄을 점유한다. {display: inline-block;} {display: inline;} 과 {display: block} 의 혼합된 형태로 대부분의 inline 특성을 가져갑니다. width/height 적용 가능 margin/padding-top/padding-bottom 적용 가능 line-height 적용 가능 {display: block} 끼리 공백이 생기게 되는데이는 상위 에 {font-size: 0} 를 적용하면 해결 가능하다. 참고 자료https://blog.naver.com/leesd88/220682157303 Keyframes @keyframes ANIMATION_NAME_1 { from {opacity: 0;} to {opacity: 1;} } @keyframes ANIMATION_NAME_2 { 0% {opacity: 0;} 25% {opacity: 0.25;} 50% {opacity: 0.5;} 75% {opacity: 0.75;} 100% {opacity: 1;} } .CLASS_NAME {animation: ANIMATION_NAME_1 3s infinite;} Animation 에 대한 적정한 사용 CSS Animation : 간단한 UI 요소 JS Animation : 바운스, 중지, 일시정지, 되감기, 가속 등과 같은 고급효과 "},"02.-front-end/03.-javascript/":{"url":"02.-front-end/03.-javascript/","title":"03. Javascript","keywords":"","body":"03. Javascript 공백 체크 Example #1 : JS - ES5 var blankPattern = /^\\s+|\\s+$/g; console.log(' '.replace(blankPattern, '')); // \"\" console.log(blankPattern.test('')); // false console.log(blankPattern.test(' ')); // true 조건문 Javascript 에서 if 문에 들어가는 조건식이 다음과 같은 제한 사항을 갖는다. Example #1 : JS - ES5 console.log(null ? 'A' : 'B') // B console.log(undefined ? 'A' : 'B') // B console.log('' ? 'A' : 'B') // B console.log(0 ? 'A' : 'B') // B console.log(' ' ? 'A' : 'B') // A console.log(-1 ? 'A' : 'B') // A "},"02.-front-end/03.-javascript/01.-general/":{"url":"02.-front-end/03.-javascript/01.-general/","title":"01. General","keywords":"","body":"01. General Strict Mode (엄격 모드) 스크립트 상단 혹은 함수의 시작 부분의 'use strict' 을 선언하면 Strict Mode 로 코드를 작성 할 수 있다. 'use strict'; /* statement */ function foo () { 'use strict'; /* statement */ } Strict Mode 는 문법검사와 런타임 동작을 검사해주는 기능을 하는데 그 역활은 다음과 같다. 경고를 에러로 변환 read only 객체는 수정불가 get 으로 선언된 객체는 수정불가 extensible 특성이 false 로 설정된 객체의 속성 확장 불가 delete 연산 사용 불가 Literal Object 의 동일한 이름의 Property 생성 불가 8 진수 및 Literal 및 escape 문 사용 불가 Reference http://beomy.tistory.com/13 일급객체 (First-Class Object) 자바스크립트는 일급객체 (First-Class Object) 입니다.일급 객체 (First-Class Object) 는 다음과 같은 특징을 갖습니다. 일급 객체는 변수에 저장 가능 해야 한다. 일급 객체는 함수의 파라미터로 전달할 수 있어야 한다. 일급 객체는 함수의 반환값으로 사용할 수 있어야 한다. 일급 객체는 자료구조에 저장할 수 있어야 한다. JSONP 웹 브라우저는 SOP (same origin policy: 동일출처정책) 에 따라 서로 다른 도메인간의 데이터 통신을 제한하고 있다script 코드가 DOM 트리에 추가되어 실행되면 외부 스크립트를 로드할 수 있다는 것 에서 착안 태그는 SOP 정책에 속하지 않기 때문에 jsonp (json width padding) 이 사용됨 JSONP 의 callback 은 서버에서 지원 해줘야 정상적으로 사용이 가능 스크립트 태그 삽입으로 callback 함수 jsonp 구현하기 var callback = '_callback_jsonp_' + Math.round(10000 * Math.random()); var script = document.createElement('script'); script.src = 'http://localhost:8080/getJSON.json?callback=' + callback; document.body.appendChild(script); window[callback] = function (data) { delete window[callback]; /* 콜백 실행 로직 */ } 요청 URL 뒤에 callback 파라메터 추가하여 jsonp 요청 구현하기 Client $.getJSON('/jsonp.json?callback=?', function (data) { console.log('success: ', data); }); Server private void doGet(HttpServletRequest request, HttpServleteResponse response) throws ServletException, IOException { request.setCharacterEncoding(\"UTF-8\"); response.setCharacterEncoding(\"UTF-8\"); String id = request.getParameter(\"id\"); String callBack = request.getParameter(\"callback\"); JSONObject obj = new JSONObject(); obj.put(\"result\", id); obj.put(\"go\", \"테스트\"); PrintWriter out = response.getWriter(); out.write(callBack + \"(\" + obj.toString() + \")\"); System.out.println(callBack + \"(\" + obj.toString() + \")\"); out.flush(); out.close(); } 요청 json 에 callback 함수로 한번 감싸서 jsonp 구현하기 Client $.ajax({ url: \"/jsonp.json\", dataType: 'jsonp', jsonpCallback: \"myCallback\", success: function(data) { console.log('성공 - ', data); }, error: function(xhr) { console.log('실패 - ', xhr); } }); Server myCallback({\"message\":\"You got an AJAX response via JSONP from another site!\"}); jsonpCallback 옵션 없이 사용하기 Client $.ajax({ url: \"/jsonp.json\", dataType: 'jsonp', success: function(data) { console.log('성공 - ', data); }, error: function(xhr) { console.log('실패 - ', xhr); } }); Server jQuery18305806868467951786_1366340807385({\"key\":\"value\"}); jsonp 로 전달 받는 응답데이터는 다음과 같다. _callback_jsonp_({ \"code\": 1, \"message\": \"success\", \"result_set\": {} }); INFO 전달 받는 데이터를 콜백 함수의 매개변수로 전달하여 실행 시키는 구조 CORS 설정을 한다면 별도의 jsonp 작업은 필요 없다. 요청 데이터의 응답 헤더가 Access-Control-Allow-Orign: * 으로 변경 암묵적 전역 자바스크립트 내에 변수 선언시에 선언자 (var) 가 없으면 암묵적 전역 으로 인해 전역 프로퍼티로 등록 된다. var a = 0; b = 2; (function () { c = 3; }()); delete a; delete b; delete c; console.log(typeof a); // number console.log(typeof b); // undefined console.log(typeof c); // undefined 프로퍼티는 delete 연산자로 삭제 가능 상속 (Inheritance) 프로토 타입을 이용한 확장 자바스크립트에는 자바와 달리 class 가 존재하지 않아 prototype 을 사용하여 class 를 구현합니다. 상속 Class 생성 Example #1 : JS - ES5 function Shape() { this.x = 0; this.y = 0; } Shape.prototype.move = function (x, y) { this.x += x; this.y += y; } function Rectangle() { Shape.call(this); } Rectangle.prototype = Object.create(Shape.prototype); Rectangle.prototype.constructor = Rectangle; 상속 객체 생성 Example #1 : JS - ES5 var rect = new Rectangle(); console.log(rect instanceof Rectangle); console.log(rect instanceof Shape); rect.move(1, 1); 프로토타입의 확장을 이용한 방법 은 Monkey Patching 이라고도 하며 권장하지 않는 방법 이다. Object.create() 를 이용한 메소드 상속 Example #1 : JS - ES5 var parent = { num: 2, increase: function () { return (this.num + 1); } } console.log(parent.increase()); // 3 var child = Object.create(parent); child.num = 12; console.log(child.increase()); // 13 자료형 (변수형) 에 대한 차이점 ES 5 & 6 에 지원하는 자료형 (변수형) var let const 은 다음과 같은 차이점을 가진다. var let const 유효범위 function scope block scope block scope 재할당 O O X 호이스팅 (Hoisting) 자바스크립트 엔진이 실행 컨텍스트를 생성하면서 scope 를 정의할 때 기술된 순서에 상관없이 선언부에 대한 처리 해석의 우선순위를 최우선으로 끌어올려 먼저 해석 하는 것이는 다음과 같은 특징을 갖는다. 변수의 정의가 그 범위에 따라 선언과 할당으로 분리 한다. 선언과 할당이 분리되며 에러를 야기시킬 수 있다. ES6 에서는 호이스팅의 지원이 없어졌다. (ES5 식의 호이스팅 / TDZ 관점) 기존 ES5 에서는 호이스팅이 있어 해당 값을 선언 후 호출하면 undefined 로 나온다. 예제 코드 Example #1 : JS - ES5 var value = 'outer scope'; (function () { console.log(value); // undefined var value = 'inner scope'; }); 위 코드는 아래와 같이 해석 된다. var value = 'outer scope'; (function () { var value; console.log(value); // undefined var value = 'inner scope'; }); var 에 비해 const/let 은 TDZ 에 의해서 ReferenceError 가 발생한다. const value = 'outer scope'; (function () { console.log(value); const value = 'inner scope'; }()); TDZ (Temporal Dead Zone) ? 초기화 (선언) 가 되지 않는 객체들을 참조 할 수 없다.(호이스팅이 되지 않는것은 아님 - ES5 처럼 undefined 로 선 할당이 안됨) 함수의 선언과 표현식 함수 선언식 (Function Declarations / Function Statement) 실행 가능한 상태가 아니며 함수의 정의를 나타내는 Statement 으로 코드 해석에 따른 수행 경과가 존재 하지 않는다. Example #1 : JS - ES5 // 함수 선언식 function foo() { /* statement */ } 함수 표현식 (Function Expressions / Function Literal) 실행 가능한 상태 코드 로 해석되어 지거나 혹은 변수나 데이터 구조에 할당 되어 있음을 의미한다. Example #1 : JS - ES5 // 함수 표현식 var foo = function () { /* statement */ } 함수의 선언식은 호이스팅에 영향 을 받지만, 함수의 표현식은 호이스팅에 영향을 받지 않는다. 익명 함수 (Anonymouse Function) 함수의 선언이 아닌 함수 표현식을 이용하는 방법 이며 즉시 실행 구문을 만들때 많이 사용된다. 익명 함수는 동적으로 할당되는 유효범위를 가지기 때문에 강제적인 유효범위를 설정 하는 경우에도 사용 된다. Example #1 : JS - ES5 (function () { var value = 'Hello World'; }()); console.log(value); // ReferenceError: value is not defined 즉시 실행 구문 (IIFE : Immediately-Invoked Function Expression) 익명 함수 (Anonymouse Function) 를 이용하여 바로 실행 가능한 함수 표현식을 이용 하여 만들어 내는 구문 Example #1 : JS - ES5 (function () { /* 실행코드 */ }()); Strict Mode ECMA5 의 엄격모드는 다음과 같은 특징을 가집니다.이 구문은 전체 스크립트 문 혹은 부분 함수에 적용이 가능하다. ({} 로 묶은 블럭문에는 적용불가) Syntax 'use strict'; 특징 기존에는 무시되던 에러들을 Throwing 한다. 최적화 작업을 도와준다. (특정 스크립트 코드가 빨리 해석되게끔 함) 향후 버전에서 정의될 문법들을 금지한다. Referencehttps://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Strict_mode "},"02.-front-end/03.-javascript/01.-general/design-pattern.html":{"url":"02.-front-end/03.-javascript/01.-general/design-pattern.html","title":"Design Pattern","keywords":"","body":"Design Pattern 네임스페이스 패턴 지역/전역 객체를 선언하여 그 안에 값을 삽입하여 사용하는 것 권장 패턴 var App = App || {}; App.Parent = function () {}; App.Child = function () {}; App.container = 1; App.module = { module_1: { data: {a: 1, b: 2} }, module_2: {} }; 안티 패턴 function Parent() {} function Child() {} var some_var = 1; var module1 = {}; module.data = {a : 1, b : 2}; var module2 = {} 모듈 패턴 기본 모듈 패턴 public 과 private 의 접근 권한을 가능하게 한다. (function () { // private 변수들과 함수들을 선언 return { // public 변수들과 함수들을 선언 }; }()); var HTMLChanger = (function() { var contents = 'contents'; var changeHTML = function () { var element = document.getElementById('attribute-to-change'); element.innerHTML = contents; } return { callChangeHTML: function () { changeHTML(); console.log(contents); } }; }()); HTMLChanger.callChangeHTML(); // 'contents' console.log(HTMLChanger.contents); // undefined 권장 모듈 패턴 Module Scope 내에서 사용할 변수 작성 Utility Method 작성 DOM 조작 메소드 작성 Event Handler 작성 Public Method 작성 var module = (function () { // 1. Module Scope 내에서 사용할 변수 작성 var scopeVal = {}, utilMethod, manipulateDOM, eventHandler, initModule; // 2. Utility Method 작성 utilMethod = function () { /* 실행 코드 */ }; // 3. DOM 조작 메소드 작성 manipulateDOM = function () { /* 실행 코드 */ } // 4. Event Handler 작성 eventHandler = function () { /* 실행 코드 */ } // 5. Public Method 작성 return { init: initMethod }; }()); 커링 여러개의 인자를 받는 함수가 있을 경우 일부의 인자만 받는 함수를 만드는 기법 Currying Example function volume(l, w, h) { return l * w * h; } function curry(fn) { var arity = fn.length; return (function resolver() { var memory = Array.prototype.slice.call(arguments); return function () { var local = memory.slice(); Array.prototype.push.apply(local, arguments); var next = (local.length >= arity? fn : resolver); return next.apply(null, local); }; }()); } Example #1 : JS - ES5 var curried = curry(volume), length = curried(2), lengthAndWidth = length(3); console.log(lengthAndWidth(4)); Example #2 : JS - ES5 var _curried = curry(volume); console.log(_curried(2)(3)(4)); Case 2 가 10배정도 빠름 메모이제이션 이전에 연산된 결과를 저장하고 사용하는 패턴메모리 상에 임시 저장값을 저장하여 사용할 수 있어 시간 복잡도를 많이 줄인다. 일반적인 피보나치 로직 var count = 0; var fibonacci = function (n) { count++; return n 메모이제이션을 사용한 피보나치 로직 1 var fibonacci = function () { var memo = [0, 1]; var count = 0; var fib = function (n) { count++; var result = meno[n]; if (typeof result !== 'number') { result = fib(n - 1) + fib(n - 2); memo[n] = result; } return result; }; return fib; } for (var i = 0; i 메모이제이션을 사용한 피보나치 로직 2 var factorial = (function () { var save = {}; var fact = function (number) { if (number > 0) { var saved = save[number - 1] || fact(number - 1); var result = number * saved; save[number] = result; console.log(saved, result); return result; } else { return 1; } } return fact; }()); factorial(7); "},"02.-front-end/03.-javascript/01.-general/web-api/":{"url":"02.-front-end/03.-javascript/01.-general/web-api/","title":"Web API","keywords":"","body":"Web API XMLHttpRequest 서버와의 비동기 데이터 통신을 하기 위해서 XMLHttpRequest 객체를 할 수 있다.기존의 자바스크립트의 ajax 을 사용하는 것과 동일하다. 1. HTTP Request 생성 모든 브라우저에서 사용 가능한 인스턴스를 생성한다. var xhr if (window.XMLHttpRequest) { xhr = new XMLHttpRequest(); } else if (window.ActiveXObject) { xhr = new ActiveXObject('Microsoft.XMLHTTP'); } 2. 응답 데이터를 처리할 callback 함수를 정의 var successCallback = function () { // 서버에서 받은 응답을 프로세싱 } xhr.onreadystatechange = successCallback; 3. 요청 (Request) 와 응답 (Response) 을 정의 xhr.open('GET', '/json', true); xhr.send(null); open Parameter method GET, POST, HEAD 대문자 로 표기하는 것을 권한다 (일부 브라우저에서는 비 동작할 수 있음) url 요청할 서버의 경로를 입력한다. async 수행 방식을 결정한다 (동기 / 비 동기) send Parameter POST 방식으로 요구 한 경우 서버로 보낼 데이터를 정의한다 json , soap 혹은 쿼리 스트링으로 표현 가능 POST 로 통신할 경우 요청 (request) MINE type을 설정 해야 합니다.예를 들면 send 를 호출하기 전에 아래와 같은 형태로 send 로 보낼 쿼리를 이용해야 한다. xhr.setReqeustHeader('Content-Type', 'application/x-www-form-urlencoded'); 4. 응답 데이터 처리 데이터 요청 (request) 하였을때의 응답 (response) 처리를 해야 한다. 응답에 사용되는 callback 함수에서 XMLHttpRequest 객체는 readyState 다음과 같은 응답 요구 상태값을 가진다. readyState 가 가질 수 있는 응답 상태 값 0 (uninitialized) 객체가 막 생성되었다. open 메소드가 수행 되지 않았다. 1 (loading) send 메소드가 수행 되지 않았다. 2 (loaded) send 메소드가 수행 되었지만 요청 헤더를 사용할 수 없다. 3 (interactive) 일부 데이터만 수신한 상태이며, 상태 및 응답 헤더는 사용가능 요청 수행중 4 (complete) 요청한 데이터를 전부 받은 상태이다. 요청 및 응답이 완료됨 동일하게 XMLHttpRequest 객체는 state 다음과 같은 상태값을 가진다. 200 정상 403 권한 부족 혹은 접근 금지 404 페이지를 찾을 수 없음 var successCallback = function () { if (xhr.readState === 4 && xhr.status === 200) { console.log('Success'); } else { console.log('Failed'); } } 5. 최종 완료 코드 var xhr = new XMLHttpRequest(); xhr.open('GET', '/json', true); xhr.onreadystatechange = function (obj) { if (xhr.readyState === 4 && xhr.status === 200) { /* 성공 코드 */ var responseObj = JSON.stringify(xhr.responseText); } else { /* 실패 코드 */ } }; xhr.send(null); 프로그래스 모니터링 XMLHttpRequest 가 지원하는 nsIJSXMLHttpRequest 인터페이스는 요청이 처리되는 동안 발생되는 이벤트가 수신 가능하며 주기적인 진행상태 알림 및 에러 알림 등을 확인 가능 하다 var onProgress = function (e) { var percent = (e.position / e.totalSize) * 100; ... } var onError = function (e) { console.log('Error ', e.target.status, ' occurred while receving the document'); } ... var xhr = new XMLHttpRequest(); xhr.open('GET', '/json', true); xhr.onprogress = onProgress; xhr.onload = onLoad; xhr.onerror = onError; xhr.send(null); onprogress 의 속성인 position 과 totalSize 는 받은 데이터가 몇 바이트인지, 전체 데이터 크기가 몇 바이트인지 각각 나타냅니다. 모든 이벤트는 그에 대응하는 XMLHttpRequest 를 target 속성으로 가지고 있습니다. "},"02.-front-end/03.-javascript/01.-general/web-api/web-api.html":{"url":"02.-front-end/03.-javascript/01.-general/web-api/web-api.html","title":"Window","keywords":"","body":"Window SetTimeout WindowTimers 에서 지원하는 타이머 객체로서자바스크립트 엔진이 일정시간 대기하였다가 UI 큐에 작업을 추가 한다. Syntax [window.]setTimeout(callback[, delay[, param1[, ... paramN]]]); Parameter window this 객체가 window 일때 생략 가능 callback 지연된 시간이 끝난 후 실행되는 콜백 함수 delay 함수 지연 시간 (default : 0) param1 ... paramN 콜백 함수로 전달될 매개변수 IE9 이하에서는 매개변수 전달이 안된다. (IE 10 이상 지원) Example #1 : JS - ES5 var timeoutId; // 타이머 세팅 function setTimer() { timeoutId = window.setTimeout(function () { alert('Notice'); }, 2000); } // 타이머 삭제 function cancleTimer() { window.clearTimeout(timeoutId); } 지정된 시간 이후에 UI 작업 큐에 추가되기 때문에 실제로 언제 실행 되는지는 알 수 없다. SetInterval 일정한 주기를 기간으로 callback 함수를 호출 합니다. Syntax [window.]setInterval(callback, delay[, param1[, ... paramN]]); Parameter window this 객체가 window 일때 생략 가능 callback 지연된 시간이 끝난 후 실행되는 콜백 함수 delay 함수 지연 시간 (default : 0) param1 ... paramN 콜백 함수로 전달될 매개변수 IE9 이하에서는 매개변수 전달이 안된다. (IE 10 이상 지원) Example var intervalID; // 타이머 세팅 function setTimer() { intervalId = window.setInterval(function () { alert('Notice'); }, 2000); } // 타이머 삭제 function cancleTimer() { window.clearInterval(intervalId); } RequestAnimationFrame 브라우저에게 callback 함수를 (프레임 단위로 처리되는) 호출 하도록 합니다.이 callback 은 보통 1초에 60회 정도 호출되게 설계되어 있지만W3C 권장사항에 따라 디스플레이의 주사율과 일치하도록 실행 됩니다. 에서는 requestAnimationFrame() 의 호출이 멈출수 있습니다. Syntax [window.]requestAnimationFrame(callback); "},"02.-front-end/03.-javascript/01.-general/web-api/dom.html":{"url":"02.-front-end/03.-javascript/01.-general/web-api/dom.html","title":"DOM","summary":"문서 객체 모델 (Document Object Model)","keywords":"","body":"DOM "},"02.-front-end/03.-javascript/02.-references/":{"url":"02.-front-end/03.-javascript/02.-references/","title":"02. References","summary":"표준 내장 객체","keywords":"","body":"02. References "},"02.-front-end/03.-javascript/02.-references/built-in-object/":{"url":"02.-front-end/03.-javascript/02.-references/built-in-object/","title":"Built-in Object","summary":"자바스크립트의 함수 객체를 정의합니다.","keywords":"","body":"Built-in Object "},"02.-front-end/03.-javascript/02.-references/built-in-object/array.html":{"url":"02.-front-end/03.-javascript/02.-references/built-in-object/array.html","title":"Array","keywords":"","body":"Array concat Description concat 메서드는 인자로 주어진 배열이나 값들을 기존 배열에 합쳐서 새로운 배열을 반환 합니다. Syntax arrayObj1.concat(arrayObj2) Parameter arrayObj1, arrayObj2 Array 객체 Example ['H', 'e', 'l', 'l', 'o'].concat(['W', 'o', 'r', 'l', 'd']); // ['H', 'e', 'l', 'l', 'o', 'W', 'o', 'r', 'l', 'd'] 이 메소드는 새로운 배열 객체를 반환 합니다. slice Description 특정 배열의 start 와 end 인덱스의 새로운 배열 객체를 반환 합니다. Syntax arrayObj.slice(start, [end]) Parameter arrayObj Array 객체 start arrayObject 에 대한 지정된 부분의 시작 end arrayObject 에 대한 지정된 부분의 끝 Example ['H', 'e', 'l', 'l', 'o'].slice(1) // ['e', 'l', 'l', 'o'] ['H', 'e', 'l', 'l', 'o'].slice(1, 4) // ['e', 'l', 'l'] ['H', 'e', 'l', 'l', 'o'].slice(0, -1) // ['H', 'e', 'l', 'l'] ['H', 'e', 'l', 'l', 'o'].slice(-1, 0) // [] 이 메소드는 새로운 배열 객체를 반환 합니다. shift Description 배열의 첫번째 요소를 제거하고, 제거된 요소를 반환합니다. Syntax arrayObj.shift() Example var arrayObj = ['H', 'e', 'l', 'l', 'o']; var shifted = arrayObj.shift(); console.log(shifted); // 'H' console.log(arrayObj); // ['e', 'l', 'l', 'o'] while 구문 수행시 첫번째 요소를 제거하면서 빈 배열이 나올때까지 반복문을 수행한다. var names = [\"Andrew\", \"Edward\", \"Paul\", \"Chris\" ,\"John\"]; while( (i = names.shift()) !== undefined ) { console.log(i); } // Andrew, Edward, Paul, Chris, John 이 메소드는 배열의 길이를 변하게 합니다. 배열의 마지막 요소를 제거하는건 pop 메소드 이다. unshift Description 새로운 요소를 배열의 앞쪽에 추가한다.return 값은 새로운 요소가 추가된 배열이다. Syntax arrayObj.unshift([element1[, ...[, elementN]]]) Example var arrayObj = ['1', '2']; arrayObj.unshift(0); // arr is [0, 1, 2] arrayObj.unshift(-2, -1); // arr is [-2, -1, 0, 1, 2] arrayObj.unshift([-3]); // arr is [[-3], -2, -1, 0, 1, 2] 이 메소드는 배열의 길이를 변하게 합니다. map Description map() 메소드는 배열내의 모든 요소에 대하여 제공된 함수(callback)를 호출하고, 그 결과를 모아서 새로운 배열을 반환 합니다. Syntax var newAry = arrayObj.map(function callback(currentValue[, index[, array]]) { // newAry 의 새 요소를 반환 }[, thisArg]); Parameter callback 새로운 배열 요소를 생성하는 함수 currentValue 배열 요소 중 현재 처리되고 있는 요소 index 현재 처리되는 요소의 배열 내 인덱스 array map 메소드가 적용되는 본래의 배열 thisArg callback을 실행할 때 this로 사용되는 값 (기본값은 window 객체) Example var numbers = [1, 4, 9]; var roots = numbers.map(Math.sqrt); console.log(numbers); // [1, 4, 9] console.log(roots); // [1, 2, 3] var numbers = [1, 4, 9]; var doubles = numbers.map(function (num) { return num * 2; }); console.log(doubles); // [2, 8, 18] var mapAry = [{key: 1, value, 10}, {key: 2, value: 20}, {key: 3, value: 30}]; var new_mapAry = mapAry.map(function (obj) { var new_obj = {} new_obj[obj.key] = obj.value; return new_obj; }); console.log(new_mapAry); // [{1:10}, {2:20}, {3:30}] 지정된 사이즈로 임의의 배열 생성 var SIZE = 10; var getRandomNumber = function (min, max, floor) { /* 랜덤 값 제조 */ }; var newArray = Array .apply(null, {length: SIZE}) .map(Function.call, function () { return getRandomNumber(MIN, MAX) }); 이 메소드는 새로운 배열 객체를 반환 합니다. filter Description filter() 메소드는 배열내의 모든 요소에 대하여 제공된 테스트 함수(callback)를 호출하고, 그 결과를 모아서 새로운 배열을 반환 합니다. Syntax var newAry = arrayObj.filter(function callback(currentValue[, index[, array]]) { // 반환형이 boolean 값 true 이면 값이 유지, false 이면 값 삭제 }[, thisArg]); Parameter callback 새로운 배열 요소를 생성하는 함수 currentValue 배열 요소 중 현재 처리되고 있는 요소 index 현재 처리되는 요소의 배열 내 인덱스 array map 메소드가 적용되는 본래의 배열 thisArg callback을 실행할 때 this로 사용되는 값 (기본값은 window 객체) Example function isBigEnough(value) { return value >= 10; } var filterd = [12, 5, 8, 130, 44].filter(isBigEnough); console.log(filtered); // [12, 130, 44] 이 메소드는 새로운 배열 객체를 반환 합니다. forEach Description forEach() 메소드는 배열 요소마다 한 번씩 제공된 함수(callback) 함수를 호출해서 사용합니다. Syntax arrayObj.forEach(function callback(currentValue[, index[, array]]) { // 반환형 없이 각 요소마다 함수를 실행 }[, thisArg]); Parameter callback 새로운 배열 요소를 생성하는 함수 currentValue 배열 요소 중 현재 처리되고 있는 요소 index 현재 처리되는 요소의 배열 내 인덱스 array map 메소드가 적용되는 본래의 배열 thisArg callback을 실행할 때 this로 사용되는 값 (기본값은 window 객체) sort Description sort() 메서드는 배열의 요소를 적절한 위치에 정렬하고 배열을 반환합니다.기본 정렬 순서는 유니 코드 포인트에 따릅니다. Syntax arrayObj.sort([compareFunction]) Parameter compareFunction 정렬 순서를 정의하는 함수를 지정합니다. (미 지정시 기본 정렬 순서에 따름) Example var fruit = ['orange', 'apple', 'banana']; console.log(fruit.sort()); // ['apple', 'banana', 'orange'] var score = [4, 11, 2, 10, 3, 1]; // ASCII 문자 순서로 정렬되어 숫자의 크기대로 나오지 않음 // [1, 10, 11, 2, 3, 4] score.sort(); // 오름차순 정렬 // [1, 2, 3, 4, 10, 11] score.sort(function () { return a - b; }); // 내림차순 정렬 // [11, 10, 4, 3, 2, 1] score.sort(function () { return b - a; }); var student = { { name: 'Edward', value: 21 }, { name: 'Sharpe', value: 37 }, { name: 'And', value: 45 }, { name: 'The', value: -12 }, { name: 'Magnetic' }, { name: 'Zeros', value: 37 } }; // value 기준으로 정렬 student.sort(function (a, b) { if (a.value > b.value) { return 1; } if (a.value nameB) { return 1; } // 이름이 같을 경우 return 0; }); 기존순서는 그대로 두고 중복 제거 var names = [\"Mike\",\"Matt\",\"Nancy\",\"Adam\",\"Jenny\",\"Nancy\",\"Carl\"]; var uniq = names.reduce(function (a, b){ if (a.indexOf(b) 기존순서는 그대로 두고 중복 제거 var uniq = names.slice() // 정렬하기 전에 복사본을 만든다. .sort(function (a, b){ return a - b; }) .reduce(function (a, b){ if (a.slice(-1)[0] !== b) a.push(b); // slice(-1)[0] 을 통해 마지막 아이템을 가져온다. return a; },[]); //a가 시작될 때를 위한 비어있는 배열 // 한 줄로 표현 return names.slice().sort(function(a,b){return a - b}).reduce(function(a,b){if (a.slice(-1)[0] !== b) a.push(b);return a;},[]); indexOf Description indexOf 메서드는 배열에서 지정된 요소를 찾을 수있는 첫 번째 인덱스를 반환하고 존재하지 않으면 -1을 반환합니다. Syntax arrayObj.indexOf(element) Parameter arrayObj 배열 객체 element 찾을 요소 Example var a = [2, 9, 9]; a.indexOf(2); // 0 a.indexOf(7); // -1 if (a.indexOf(7) === -1) { // 요소가 배열에 존재하지 않습니다. } Polyfill IE 8 이하 지원 안함 var indexOf = Array.prototype.indexOf || (function (prop, s) { for (var i = (s || 0); i if (indexOf.call(arrayObj, value) > -1) { console.log('value is contain'); } else { console.log('value is not contain'); } "},"02.-front-end/03.-javascript/02.-references/built-in-object/object.html":{"url":"02.-front-end/03.-javascript/02.-references/built-in-object/object.html","title":"Object","keywords":"","body":"Object Object Keys Length Description object 타입의 데이터 중에 키의 갯수를 구한다. Syntax Object.keys(obj).length Example #1 : JS - ES5 var obj = {a: 1, b: 2: c: 3}; var size = Object.keys(obj).length; console.log(size); // 3 assign Description assign() 메소드는 열거할 수 있는 하나의 이상의 소스 오브젝트의 프로퍼티들을 복사합니다. Syntax Object.assign(target [, sources]) Parameter target 타겟 오브젝트 sources 하나 이상의 소스 오브젝트 Example var obj = {a: 1}; var cp_obj = Object.assign({}, obj); console.log(cp_obj); // {a: 1} var obj1 = { a: 1 }; var obj2 = { b: 2 }; var obj3 = { c: 3 }; var obj = Object.assign(o1, o2, o3); console.log(obj); // { a: 1, b: 2, c: 3 } console.log(obj1); // { a: 1, b: 2, c: 3 }, 타겟 오브젝트, 그 자체도 변화합니다. var obj1 = { a: 1, b: 1, c: 1 }; var obj2 = { b: 2, c: 2 }; var obj3 = { c: 3 }; var obj = Object.assign({}, obj1, obj2, obj3); console.log(obj); // { a: 1, b: 2, c: 3 } Polyfill if (typeof Object.assign != 'function') { (function () { Object.assign = function (target) { 'use strict'; if (target === undefined || target === null) { throw new TypeError('Cannot convert undefined or null to object'); } var output = Object(target); for (var index = 1; index hasOwnProperty Description hasOwnProperty() 메소드는 객체가 특정 프로퍼티를 가지고 있는지 확인 합니다. Syntax Object.hasOwnProperty(prop) Parameter prop 확인 하려는 프로퍼티 명칭 Example var obj = new Object(); obj.prop = 'exists'; obj.hasOwnProperty('prop'); // true delete obj.prop(); obj.hasOwnProperty('prop'); // false var obj = new Object(); obj.prop = 'exists'; obj.hasOwnProperty('prop'); // true // 상속된 프로퍼티는 검사할 수 없다. obj.hasOwnProperty('toString'); // false obj.hasOwnProperty('hasOwnProperty'); // false var obj = { hasOwnProperty: function() { return false; }, bar: 'Here be dragons' }; foo.hasOwnProperty('bar'); // false ({}).hasOwnProperty.call(foo, 'bar'); // true Object.prototype.hasOwnProperty.call(foo, 'bar'); // true "},"02.-front-end/03.-javascript/02.-references/built-in-object/function.html":{"url":"02.-front-end/03.-javascript/02.-references/built-in-object/function.html","title":"Function","keywords":"","body":"Function bind Description bind() 메소드는 호출될 때 그 this 키워드를 제공한 값으로 설정하고 새로운 함수를 생성합니다.실행하지 않고 함수만 반환 한다. Syntax func.bind(thisArg[, arg1[, arg2[, ... ]]]; Parameters thisArg 바인딩된 함수가 호출될 때 대상함수에 this 매개변수로서 전달되는 값 arg1, arg2, ... 대상 함수를 호출할 때 바인딩된 함수에 제공되는 인수 Retrun Value 지정된 this 값 및 초기 인수가 있는 주어진 함수의 복제본 call Description call() 메소드는 호출될 때 제공된 this 키워드 값과 인수를 함께 호출합니다. Syntax func.call(thisArg[, arg1[, arg2[, ... ]]]; Parameters thisArg 바인딩된 함수가 호출될 때 대상함수에 this 매개변수로서 전달되는 값 arg1, arg2, ... 대상 함수를 호출할 때 바인딩된 함수에 제공되는 인수 apply Description apply() 메소드는 호출될 때 제공된 this 키워드 값과 인수를 함께 호출합니다. Syntax func.call(thisArg, [argsArray]; Parameters thisArg 바인딩된 함수가 호출될 때 대상함수에 this 매개변수로서 전달되는 값 argsArray 대상 함수를 호출할 때 바인딩된 함수에 제공되는 인수의 배열 addEventListener Description 이벤트 타겟에서 사용할 리스너를 등록합니다. Syntax target.addEventListener(type, listener [, useCapture]); Parameter target * type 등록할 이벤트 타입 click mousedown mouseup keyup keydown keypress 등등... listener 특정 타입의 이벤트가 발생할 때 받을 객체 반드시 function 타입 useCapture 이벤트 캡쳐링/버블링 유무 참고 자료http://sculove.github.io/blog/2016/12/29/addEventListener-passive/ "},"02.-front-end/03.-javascript/02.-references/operator-and-expression.html":{"url":"02.-front-end/03.-javascript/02.-references/operator-and-expression.html","title":"Operator & Expression","keywords":"","body":"Operator & Expression in Description in 연산자는 명시된 속성이 객체에 존재하면 true 를 반환합니다. Syntax 속성 in 객체명 Parameters 속성 속성의 이름이나 배열의 인덱스를 뜻하는 문자열 또는 수의 값입니다. 객체명 객체의 명칭 Example var arrayObj = ['a', 'b', 'c']; console.log(3 in arrayObj); // false console.log(0 in arrayObj); // true console.log('a' in arrayObj); // false console.log('length' in arrayObj); // true var color1 = new String('green'); console.log('length' in color1); // true var color2 = 'Red'; console.log('length' in color2); // false // color2 는 String 객체가 아니기 때문에 오류를 발생함 String 생성자로 만들어진 문자열을 명시할 수 있지만 문자열 리터럴은 명시할 수 없다 console.log('toString' in {}); // true 프로토타입 체인에 의하여 접근 가능한 속성은 true 를 반환합니다. instanceof Description instanceof 연산자는 생성자의 prototype 속성과 묶인 프로토타입을 가진 오브젝트인지 확인합니다. Syntax object instanceof constructor Parameters object 테스트 대상인 오브젝트 constructor 테스트할 함수 (프로토타입 오브젝트) Example function C() {}; var obj = new C(); console.log(obj instanceof C); // true function Car(make, model, year) { this.make = make; this.model = model; this.year = year; } var auto = new Car('Honda', 'Accord', 1998); console.log(auto instanceof Car); // true console.log(auto instanceof Object); // true typeof Description typeof 연산자는 피연산자 타입을 가르키는 문자열을 반환합니다. 타입 결과 Undefined \"undefined\" Null \"object\" String \"string\" Number \"number\" Array \"object\" Boolean \"boolean\" Function Object \"function\" other Object \"object\" Syntax typeof 피연산자 Example console.log(typeof 100) // number console.log(typeof '100') // string console.log(typeof 'abc') // string console.log(typeof []) // object console.log(typeof undefined) // number console.log(typeof function foo() {}) // function delete Description delete 연산자는 오브젝트의 속성을 삭제한다. Syntax delete object[.property] Parameters object 오브젝트의 이름 또는 오브젝트의 표현식 property 삭제하고자 하는 속성 Example var Employee = { age: 28, name: 'abc' designation: 'developer' }; console.log(delete Employee.name); // true console.log(delete Employee.age); // true // 해당 프로퍼티가 존재하지 않아 true를 리턴합니다. console.log(delete Employee.salary); // true delete연산자의 사용시 유의사항. 존재하지 않는 속성을 삭제하려고 하면 아무 작업 없이 true를 반환 오브젝트에 프로토타입 체인과 같은 속성이 있다면 delete로 삭제 후에 프로토타입 체인 프로퍼티 사용가능 var로 선언된 프로퍼티는 삭제 불가 "},"02.-front-end/03.-javascript/02.-references/global-object.html":{"url":"02.-front-end/03.-javascript/02.-references/global-object.html","title":"Global Object","keywords":"","body":"Global Object Null 변수를 선언하고 null 객체를 삽입한 상태 (객체의 참조 연결이 해지된 것)자료형은 object 로 분류됨 console.log(typeof null); // \"object\" Undefined 변수 선언만 하고 값을 할당하지 않는 상태 (정의가 되지 않는 변수)자료형이 결정되지 않는 상태 "},"02.-front-end/03.-javascript/02.-references/ecma6/":{"url":"02.-front-end/03.-javascript/02.-references/ecma6/","title":"ECMA 6","keywords":"","body":"ECMA 6 ECMA 산하 Task Group 중에 하나의 ECMA-262 (TC39) 에서 유지 및 개선관리 되는 부분이다.ECMA Script 와 호환 및 확장되는 라이브러리 표준의 개발이다.ISO 및 IEC JTC 등의 표준을 게시한다. ECMAScript 6번째 표준 에디션 으로 많은 부분이 개선 및 추가 되었다. Function 기존 함수 선언식 (ES5) 에서 변경된 점 Example #1 : ES5 function foo() { /* statement */ } Example #2 : ES6 var obj = { foo() { /* statement */ }, poo: () => { /* statement */ } } obj.foo 과 obj.poo 는 동일한 기능을 한다. Arrows 화살표 함수 표현식은 축약형 함수 입니다. Syntax (param1, param2, ... , paramN) => { statements } Parameters statements 함수의 내용 Example #1 : ES6 // 매개변수가 하나 이상있는 경우는 괄호가 필요 (param1, param2) => { return param1 + param2 }; // 매개변수가 하나인 경우에는 괄호가 필요 없음 param1 => { return param1 + 1 } // 매개변수가 없을경우 () => { console.log('Hello World'); } Example #2 : ES6 var list = [2, 4, 6, 8]; // Expression Block 사용 안함 (표현식의 결과가 반환됨) var odd = list.map(value => value + 1); // [3, 5, 7, 9] // Expression Block 사용 (블럭 내부만 실행, 반환값을 위해서는 return 표현식을 명시해야 함) list.forEach(v => { console.log(v); }); Example #3 : ES6 // 객체 리터럴 반환 var func = () => ({ foo: 1 }); console.log(func()); // {foo: 1} Expression 선언 컨텍스트의 밖의 this 값을 가진다. this 가 바인딩 되지 않는다. function foo() { this.value = 0; setInterval(() => { console.log(this.value); // 0 }, 1000); } 생성자 (constructor) 로 사용될수 없다. (new 연산자 사용 불가) var Foo = () => {}; var foo = new Foo(); // TypeError : Foo is not a constructor Default Parameter Description 함수의 매개변수의 기본값이 설정 가능합니다. Syntax function func_name([param1[= defaultValue1][, ... , paramN[= defaultValueN]]]) { statements } Parameters func_name 함수명 param1, param2 파라메터 명 defaultValue1, defaultValue2 파라메터 기본값 statements 함수의 내용 Example #1 : ES6 function add(a, b = 1) { return a * b; } console.log(add(5)) // 5 Expression 함수에도 적용 가능하다. function callLog(msg = defaultMsg()) { return console.log(mes); } function defaultMsg() { return 'TEST_LOG'; } callLog() // TEST_LOG undefined 전달 시 function callLog(msg = 'TEST_LOG') { return console.log(mes); } callLog(undefined) // TEST_LOG Spread Operator 2개 이상의 인수를 나열하는 방식 Syntax // 함수 호출용 myFunction(...args); // 배열 리터럴용 [...args, 5, 6, 7]; // 비 구조화용 [a, b, ...args] = [1, 2, 3, 4, 5]; Example var org = [3, 4]; var custom = [1, 2, ...org, 5]; // [1, 2, 3, 4, 5] Expression 스프레드 연산자로 배열 & 객체 복제. var array = [1, 2, 3]; var cloneArray = [...array]; console.log(cloneArray); // [1, 2, 3] var obj = {a: 10, b: 20}; var cloneObj = {...obj}; console.log(cloneObj); // {a: 10, b: 20} Rest Parameter 나머지 매개변수 (rest parameter) 구문에 나머지 인수들도 정의해 나타냅니다. Syntax function (a, b, ...theArgs) { // statements } Example function foo(...Args) { console.log(Args.length); } foo(); // 0 foo(5); // 2 foo(5, 7, 9); // 3 function foo(arg1, ...Args) { return Args.map(function (elem) { return arg1 * elem }); } console.log(foo(2, 1, 2, 3)); // [2, 4, 6] Expression arguments 객체가 아닌 Array 객체의 method 사용이 가능하다. function sortRestArgs(...Args) { return Args.sort(); } function sortArguments() { return arguments.sort(); } console.log(sortRestArgs(5, 3, 7, 1)); // [1, 3, 5, 7] console.log(sortArguments(5, 3, 7, 1)); // TypeError Destructuring Syntax 구조분해 문법은 ES6 에서 사용되는 변수의 선언 방식입니다. Expression 특정 객체의 값을 꺼내오는 방법 var josh = { language: 'javascript', position: 'front-end', area: 'pangyo', hobby: 'singing', age: '102' }; var language = josh.language; var position = josh.position; var area = josh.area; var hobby = josh.hobby; var age = josh.age; var josh = { language: 'javascript', position: 'front-end', area: 'pangyo', hobby: 'singing', age: '102' }; var { language, position, area, hobby, age } = josh; console.log(language); // javascript console.log(position); // front-end console.log(area); // pangyo console.log(hobby); // singing console.log(age); // 102 함수의 적용 var context = { commit: actionName => console.log(actionName + ' has been committed!!') }; var {commit} = context; commit('addProducts'); // addProducts has been committed !! Export Syntax 지정된 파일에서 객체 (함수, 오브젝트, 원시타입) 을 export 하는데 사용된다. Syntax // Named Exports export { myFunction }; // 함수 exports export const foo = Math.sqrt(2); // 상수 exports // Default Exports (스크립트에서 유일하게 한번 사용) export default myFunctionOrClass; "},"02.-front-end/03.-javascript/02.-references/ecma6/symbol.html":{"url":"02.-front-end/03.-javascript/02.-references/ecma6/symbol.html","title":"Symbol","keywords":"","body":"Symbol ES6 에서 나온 원시 데이터형 (Primitive DataType) 의 일종으로 객체에 Unique 한 속성을 만들어 다른 라이브러리와 충동을 피하기 위함이다. Undefined Null Boolean Number String Object Symbol Syntax Symbol([description]); Parameter description 선택적 (Optional) 문자열로 디버깅에 사용할 수 있는 설명이다. 자체적으로 심볼에 접근하는 용도로 사용할 수 없음 Description 기본적으로 새 원시 심볼을 생성하려면 아래와 같이 선택적 문자열과 함께 Symbol() 을 쓰면 된다. var sym1 = Symbol(); var sym2 = Symbol('foo'); var sym3 = Symbol('foo'); 매번 새로운 심볼을 생성하기 때문에 아래 같이은 조건은 성립할 수 없다. console.log(Symbol('foo') === Symbol('foo')) // false new 연산자를 이용한 문법은 TypeError 를 발생한다. var sym = new Symbol(); // TypeError 반드시 심볼 래퍼 객체 생성이 필요하면 Object() 함수를 이용하여 사용가능하다. var sym = Symbol('foo'); typeof sym; // \"symbol\" var symObj = Object(sym); typeof symObj; // \"object\" 심볼의 생성 심볼의 생성은 다음 3가지 방법이 있다. 고유한 심볼 생성 var sym = Symbol('foo'); 심볼 레지스트리에서 찾아서 복사 var sym = Symbol.for('foo'); 미리 정의된 상용 심볼 사용 Symbol.iterator 상용심볼은 특별한 용도를 위해서 만들어 놓은 심볼이며 대표적인 상용 심볼은 다음과 같다. Symbol.iterator 이터러블한 객체를 정의하기 위한 심볼 Symbol.hasInstance instanceof 를 확장하기 위한 심볼 Symbol.match String.prototype.match 메소드의 확장 "},"02.-front-end/03.-javascript/02.-references/ecma6/iterator.html":{"url":"02.-front-end/03.-javascript/02.-references/ecma6/iterator.html","title":"Iterator","keywords":"","body":"Iterable & Iterator 자바스크립트의 반복문의 for loop 는 다음 몇가지로 나뉜다. for 가장 기본적인 for loop forEach 배열을 순회하며 value 와 index 를 매개변수로 전달한다. break, return 으로 루프를 중단할 수 없다. for in 배열의 인덱스만 순환 하는것이 아닌 프로토타입 체인을 포함한 모든 속성을 순회한다. 배열보다는 객체를 순회 하기 위해 만들어진 루프이다. for of for in 으로 배열을 순회할 때 생기는 문제점들을 해소하였다. for of 는 순회가능한 (iterable) 객체를 상대로 사용 가능 하다. 순회가능한 (Iterable) 한 객체는 Symbol.iterator 심볼을 속성으로 가지고 있으며 이터레이터 객체를 반환하는 객체 를 뜻한다.해당 스팩을 이터러블 프로토콜 이라고 하며 해당 스팩을 구현한 객체를 이터러블 객체 라고 한다. Iterator Interface TC39 에서 정의한 Iterator Interface 정의를 따른 Object 로써 내응은 다음과 같다. Iterator Interface next 라는 키를 갖고 있으며 값으로 인자를 받지 않고 Iterator Result Object 를 반환하는 함수가 온다. Iterator Result Object 는 value 와 done 이라는 키를 갖고 있다. value 는 실제 값을 의미 done 는 계속 반복 할 수 있는지 따른 boolean 값 영원히 0 을 반환하는 Iterator { next: function () { return { value: 0, done: false }; } } 각 배열을 순회하며 배열의 끝 값을 반환하는 Iterator { data: [1, 2, 3, 4] next: function () { return { done: this.data.length === 0, value: this.data.pop() }; } } ECMA6 에서는 객체 리터럴 작성 순서에 따라 파싱 한다. 예를 들면 위 코드의 done 과 value 중에서 done 이 먼저 작성되어 있기 때문에 done 을 먼저 파싱한다.ECMA5 에서는 done 이든 value 든 어느것을 먼저 파싱할지 보장이 안됨 Iterable Object Symbol.iterator 의 키를 가지고 있는 객체로써 다음 스펙을 구현한 객체이다. Iterable Spec Symbol.iterator 의 키를 갖고 있다. 값으로 인자를 받지 않고 Iterator Object 를 반환하는 함수가 온다. { [Symbol.iterator]: function () { return { next: function { return { value: 1, done: false }; } }; } } ReferenceECMA-262 - Iterable InterfaceGDG 2016 발표자료GDG DevFest Seoul 2016 - Iterable & Iterator Generator Referencehttps://gist.github.com/qodot/ecf8d90ce291196817f8cf6117036997 "},"02.-front-end/03.-javascript/02.-references/ecma6/generator.html":{"url":"02.-front-end/03.-javascript/02.-references/ecma6/generator.html","title":"Generator","keywords":"","body":"Generator Iterator Interface 를 구현한 확장형 함수 Example #1 - ES6 function* foo() { yield '첫번째 호출'; yield '두번째 호출'; yield '세번째 호출'; yield '네번째 호출'; } var _foo = foo(); for (var i = 0; i 네번째 까지만 정상 로그가 찍히며 이후로는 { value: undefined, done: false } 로 나온다. // Object { value: '첫번째 호출', done: false } // Object { value: '두번째 호출', done: false } // Object { value: '세번째 호출', done: false } // Object { value: '네번째 호출', done: false } // Object { value: undefined, done: false } // Object { value: undefined, done: false } // Object { value: undefined, done: false } // Object { value: undefined, done: false } // Object { value: undefined, done: false } // Object { value: undefined, done: false } yield 제너레이터 함수를 중지 시키거나 재개하는데 사용한다. Syntax [rv] = yield [expression]; Parameters rv 제너레이터 실행을 재개 하기 위해서, optional value을 제너레이터의 next() 메서드로 전달하여 반환 expression 제너레이터 함수에서 제너레이터 프로토콜을 통해 반환값을 정의 한다. (Default : undefined) Reference http://hacks.mozilla.or.kr/2015/08/es6-in-depth-generators/ "},"02.-front-end/03.-javascript/03.-performance.html":{"url":"02.-front-end/03.-javascript/03.-performance.html","title":"03. Performance","keywords":"","body":"03. Performance 비 차단 스크립트 HTML Parsing 작업의 중단 없이 동시에 내려받게 됨 aync HTML 파싱과 동시에 다운 받으며 스크립트 다운로드가 끝났을 경우 HTML 파싱을 중지 시키고 스크립트 파싱한다. defer HTML 파싱과 동시에 다운 받으며 스크립트 다운로드가 끝나도 HTML 파싱이 완료된 이후에 스크립트 파싱을 시작한다. "},"02.-front-end/04.-framework/":{"url":"02.-front-end/04.-framework/","title":"04. Framework","keywords":"","body":"04. Framework 쿼리스트링 (리소스 파일 캐쉬 방지) 브라우저에서 캐의 동작은 기존에 동일한 URL 에 요청한 적이 있었는지 판단한다.따라서 수정 배포된 리소스파일 (js, css, image 등등 ...) 이 수정되면 URL 경로의 변경 혹은 쿼리스트링으로 파일 캐시를 방지한다. 코드적 장점 매번 캐시를 삭제해야 하는 불편함을 피할 수 있다. 관리적 장점 파일의 릴리즈 (release) 버전의 정보를 알기 쉽게 구분한다. "},"02.-front-end/04.-framework/node-js/":{"url":"02.-front-end/04.-framework/node-js/","title":"Node JS","keywords":"","body":"Node JS "},"02.-front-end/04.-framework/node-js/http-transection.html":{"url":"02.-front-end/04.-framework/node-js/http-transection.html","title":"HTTP Transection","keywords":"","body":"HTTP Transection 요청 처리 서버의 생성 모든 node 웹 서버 어플리케이션은 웹 서버 객체를 만들어야 합니다.이때 createServer 를 이용합니다. const http = require('http'); const server = http.createServer((request, response) => { // Work Process }); 서버로 오는 모든 HTTP 요청 마다 createServer 에 전달된 함수가 한번씩 호출된다.createServer 가 반환한 Server 객체는 EventEmitter 이고 server 객체를 생성하고 리스너를 추가하는 축약 문법이다. EventEmitter 이란 ?이벤트 모듈의 의해 정의 되며 새로운 이벤트가 추가되거나 삭제될 때 이벤트를 내보냅니다. const http = require('http'); const server = http.createServer(); server.on('request', (req, res) => { // Work Process }); HTTP 요청이 서버에 오면 node 가 트랜잭션을 다루려고 request 와 response 객체를 전달하며 요청 핸들러 함수를 호출 합니다. Method, URL, Header 의 처리 요청을 처리할 때, 우선은 Method 와 URL 을 확인한 후 이와 관련된 작업을 실행합니다.node 는 request 객체에 대부분의 프로퍼티를 넣어두므로 꺼내서 사용하면 된다. const {method, url} = request; request 객체는 IncomingMessage 의 인스턴스이다. IncomingMessage Class 의 특징 HTTP 에 의해 생성된다. 특정 객체의 첫번째 변수로 전달되는 인수 (SERVER http.ClientRequest request event response event) 응답상태 및 헤더, 데이터 등을 액세스 하는데 사용 한다. 헤더 또한 request 객체에서 얻어온다. const {headers} = request; const userAgent = header['user-agent']; Tips 클라이언트가 설정한 헤더 프로퍼티는 대소문자 구분없이 소문자로만 표현 된다.일부 헤더 정보를 반복해서 설정하면 overwrite 하거나 csv 형태로 구성될 수 있다. 이런 경우에는 rawHeaders 를 사용할 수 있다. Request Body 의 처리 post 혹은 put 요청시 핸들러에 전달된 request 객체는 ReadableStream 인터페이스를 구현하고 있다.이 스트림에 EventListener 를 등록하거나 다른 스트림의 파이프로 연결 할 수 있다. 각 data 이벤트에서 발생시킨 청크는 Buffer 이며 이는 문자열 데이터이다.이는 end 이벤트에서 이어 붙인 다음에 문자열로 만드는게 가장 좋다. let body = []; request.on('data', (chunk) => { body.push(chunk); }).on('end', () => { // `body` 에 전체 요청 바디가 문자열로 담겨 있다. body = Buffer.concat(body).toString(); }); 오류의 관한 처리 request 스트림에서 오류가 발생하면 error 이벤트가 발행하면서 오류를 전달한다.별도의 이벤트 리스너가 등록되어 있지 않다면 오류를 뱉으면서 Node.js 를 종료시킨다. request.on('error', (error) => { console.error(error.stack); }); HTTP 요청 코드 정리 const http = require('http'); http.createServer((request, response) => { const {headers, method, url} = request; let body = []; request.on('error', (error) => { console.error(error.stack); }).on('data', (chunk) => { body.push(chunk); }).on('end', () => { body = Buffer.concat(body).toString(); /** * 헤더, 메서드, 요청경로, 바디 등을 가지게 되었으며 * 이 요청에 응답하는 작업을 수행할 수 있습니다. */ }) }).listen(8080); 이 코드는 요청 받을 수 있지만 요청한 디바이스(클라이언트) 에 응답 하는 로직이 없기 때문에 타임아웃이 걸릴것 입니다. 응답 처리 응답 상태 코드 별도의 설정이 없으면 HTTP 응답 코드는 200 으로 고정 됩니다.상태 코드를 변경 하려면 statusCode 프로퍼티를 설정해야 합니다. // 리소스를 찾을수 없음 response.statusCode = 404; 응답 헤더 설정 setHeader 메서드로 헤더를 설정 한다. response.setHeader('Content-Type', 'application/json'); response.setHeader('X-Powered-By', 'bacon'); 헤더 설정 프로퍼티의 대/소문자는 구분이 없다. 명시적 응답 헤더 데이터 전송 writeHead 메소드를 이용하여 명시적으로 헤더 작성이 가능하다. response.writeHead(200, { 'Content-Type': 'application/json', 'X-Powered-By': 'bacon' }); 응답 바디 전송 response 객체는 WriteableStream 이므로 클라이언트로 보내는 응답 바디는 일반적인 스트림 메서드를 이용하여 작성 합니다. response.write(''); response.write(''); response.write('Hello, World!'); response.write(''); response.write(''); response.end(); 위 코드는 아래와 같이 작성해도 동일하다. response.end('Hello, World!'); 오류에 관한 처리 response 스트림도 error 이벤트를 발생시킬수 있고 때로는 이 오류도 처리해야 합니다.request 스트림에 대한 오류와 동일하게 적용이 가능합니다. 현재까지 적용코드 const http = require('http'); http.createServer((request, response) => { const { headers, method, url } = request; let body = []; request.on('error', (error) => { console.error(error); }).on('data', (chunk) => { body.push(chunk); }).on('end', () => { body = Buffer.concat(body).toString(); response.on('error', (error) => { console.error(error); }); response.statusCode = 200; response.setHeader('Content-Type', 'application/json'); // 위 두줄의 코드를 한줄로 가능 // response.writeHead(200, {'Content-Type': 'application/json'}); const responseBody = { headers, method, url, body }; response.write(JSON.stringify(responseBody)); response.end(); // 위 두줄의 코드를 한줄로 가능 // response.end(JSON.stringify(responseBody)); }); }).listen(8080); 에코 서버 만들기 에코서버란 요청 받은 데이터를 그대로 응답으로 돌려보내는 서버이다.앞에서 했던것 처럼 요청 스트림에서의 데이터를 가져와 응답 스트림에 쓴다. const http = require('http'); http.createServer((request, response) => { let body = []; request.on('data', (chunk) => { body.push(chunk); }).on('end', () => { body = Buffer.concat(body).toString(); response.end(body); }); }).listen(8080); 위 코드를 다음 조건에 따라 에코 응답을 보내는것으로 수정한다. 요청 메서드가 POST 인 경우 URL 이 /echo 인 경우 const http = require('http'); http.createServer((request, response) => { if (request.method === 'POST' && request.url === '/echo') { let body = []; request.on('data', (chunk) => { body.push(chunk); }).on('end', () => { body = Buffer.concat(body).toString(); response.end(body); }); } else { response.statusCode = 404; response.end(); } }).listen(8080); 위의 방법으로 라우팅을 하고 있지만 express 프레임워크나 router 라이브러리릉 통해서 처리도 가능하다. request 객체는 ReadableStream 이고 response 객체는 WriteableStream 이므로 pipe 를 사용할 수 있다. const http = require('http'); http.createServer((request, response) => { if (request.method === 'POST' && request.url === '/echo') { request.pipe('response'); } else { response.statusCode = 404; response.end() } }).listen(8080); 오류에 관한 처리 const http = require('http'); http.createServer(request, response) => { request.on('error', (error) => { console.error(error); response.statusCode = 400; response.end(); }); response.on('error', (error) =>{ console.error(error); }); if (request.method === 'POST' && request.url === '/echo') { request.pipe(response); } else { response.statusCode = 404; response.end(); } }).listen(8080); HTTP 요청을 다음 동작이 가능하다. 요청 핸들러로 HTTP 서버의 인스턴스를 생성 가능하고 특정 포트를 열 수 있다. request 객체에서 Header, Method, URL, Body` 데이터를 가져올 수 있다. URL 이나 request 객체의 기반 데이터로 라우팅이 가능하다. request 객체에서 response 객체로 데이터를 파이프로 연결 가능하다. request 와 response 스트림 모두에서 스트림 오류 처리가 가능하다. Reference URL https://nodejs.org/ko/docs/guides/anatomy-of-an-http-transaction/ "},"02.-front-end/04.-framework/node-js/express.html":{"url":"02.-front-end/04.-framework/node-js/express.html","title":"Express","keywords":"","body":"Express Route 라우팅은 요청 URI 및 특정한 HTTP 요청 메소드 (GET, POST, PUT, DELETE) 인 특정 엔드포인트 에 대한 클라이언트 요청에 대해 애플리케이션이 응답하는 방법을 결정 하는것 Syntax app.METHOD(PATH, HANDLER) Parameter app express 의 인스턴스 METHOD HTTP 요청 메소드 PATH 서버 경로 HANDLER 라우트가 일치할 때 실행되는 함수 Example 각 요청에 따른 라우트를 정의하고 이에 응답한다. var express = require('express'); var app = express(); app.get('/', function(req, res) { res.send('hello world'); }); Method 대표적인 Express 라우팅 메소드는 다음과 같다. app.get('/', function (req, res) { res.send('Hello World!'); }); app.post('/', function (req, res) { res.send('Got a POST request'); }); app.put('/user', function (req, res) { res.send('Got a PUT request at /user'); }); app.delete('/user', function (req, res) { res.send('Got a DELETE request at /user'); }); Route Chain app.route() 을 이용하면 라우트 경로에 대한 체이닝 핸들러를 작성 할 수 있다. app.route('/book') .get(function(req, res) { res.send('Get a random book'); }) .post(function(req, res) { res.send('Add a book'); }) .put(function(req, res) { res.send('Update the book'); }); all() 메소드를 통해 모든 응답의 대응도 가능. app.route('/book') .all(function(req, res) { res.send('Get a random book'); }); Route Moduler 모듈식 마운팅이 가능한 핸들러의 작성 var express = require('express'); var router = express.Router(); // middleware that is specific to this router router.use(function timeLog(req, res, next) { console.log('Time: ', Date.now()); next(); }); // define the home page route router.get('/', function(req, res) { res.send('Birds home page'); }); // define the about route router.get('/about', function(req, res) { res.send('About birds'); }); module.exports = router; var birds = require('./birds'); ... app.use('/birds', birds); /birds 및 /birds/about 에 대한 요청을 처리 가능하며 해당 라우트에 대한 특정 미들웨어 함수인 timeLog 를 호출 Express 는 HTTP 메소드에 해당하는 다음과 같은 라우팅 메소드를 지원한다. get, post, put, head, delete, options, trace, copy, lock, mkcol, move, purge, propfind, proppatch, unlock, report, mkactivity, checkout, merge, m-search, notify, subscribe, unsubscribe, patch, search및 connect. Path URI 경로는 문자열 혹은 정규식의 패턴에도 적용된다. Character Pattern // acd, abcd app.get('/ab?cd', function(req, res) { res.send('ab?cd'); }); // abcd, abbcd, abbbcd app.get('/ab+cd', function(req, res) { res.send('ab+cd'); }); // abcd, abxcd, abRABDOMcd, ab123cd app.get('/ab*cd', function(req, res) { res.send('ab*cd'); }); // /abe, /abcde app.get('/ab(cd)?e', function(req, res) { res.send('ab(cd)?e'); }); Regular Expression // a 가 포함된 모든 항목과 일치 app.get(/a/, function(req, res) { res.send('/a/'); }); // butterfly, dragonfly 과는 일치 // butterflyman, dragonfly man 과는 불일치 app.get(/.*fly$/, function(req, res) { res.send('/.*fly$/'); }); Response 응답 오브젝트에 대한 메소드는 응답을 클라이언트에 전송하고 요청 및 응답의 주기를 종료할 수 있다.라우트 핸들러로부터 다음 메소드중 하나라도 호출되지 않는 경우 클라이언트 요청은 정지된 채로 방치 된다. 메소드 설명 res.download() 파일이 다운로드되도록 프롬프트합니다. res.end() 응답 프로세스를 종료합니다. res.json() JSON 응답을 전송합니다. res.jsonp() JSONP 지원을 통해 JSON 응답을 전송합니다. res.redirect() 요청의 경로를 재지정합니다. res.render() 보기 템플리트를 렌더링합니다. res.send() 다양한 유형의 응답을 전송합니다. res.sendFile 파일을 옥텟 스트림의 형태로 전송합니다. res.sendStatus() 응답 상태 코드를 설정한 후 해당 코드를 문자열로 표현한 내용을 응답 본문으로서 전송합니다. const router = express.Router(); // 클라이언트가 루트 경로로 진입하면 /index 경로로 리다이렉트 시킨다. router.all('/', (req, res) => { res.redirect('/index'); }); // 모든 경로를 index 로 랜더링 한다. router.all('*', (req, res) => { res.render('index'); }); "},"02.-front-end/04.-framework/angular-js.html":{"url":"02.-front-end/04.-framework/angular-js.html","title":"Angular JS","keywords":"","body":"Angular JS Browser Support 2 Way Binding Angular 1에서 많은 인기를 얻었던 특징중에 ng-model 지시자 (directive) 를 이용한 양방향 데이터 바인딩 (two-way binding) 이다.UI 에 연결된 데이터가 변경되면 앱의 상태가 자동으로 업데이트 되는 기능으로 예를 들면 박스에 사용자가 텍스트를 입력하여 값을 변경하면 자동으로 UI 에 onChange 같은 콜백 함수를 이용하지 않아도 자동으로 변수가 입력된 값을 업데이트 한다. Hello, {{name}} 장점 DOM 조작이 줄어든다. 단점 불필요한 성능 저하를 가져온다. 계속해서 데이터 변화를 감지하고 바인딩 해야 하기 때문 "},"02.-front-end/04.-framework/react/":{"url":"02.-front-end/04.-framework/react/","title":"React JS","keywords":"","body":"React JS ESLint .eslintrc.json 파일에 다음과 같이 추가해준다.es6 문법과 jsx 를 혼용하기 때문에 아래와 같은 lint 설정을 추가해준다. { ... \"parserOptions\": { \"ecmaVersion\": 6, \"sourceType\": \"module\", \"ecmaFeatures\": { \"jsx\": true } } ... } React Development Tools 손쉬운 디버그 환경을 위하여 크롬 확장프로그램 (Chrome Extension) 에서 해당 플러그인을 설치한다. 참고 자료 React https://d2.naver.com/helloworld/1848131 https://reactjs.org/docs/getting-started.html https://velopert.com/3613 Redux https://deminoth.github.io/redux/ "},"02.-front-end/04.-framework/react/redux.html":{"url":"02.-front-end/04.-framework/react/redux.html","title":"Redux","summary":"자바스크립트 앱의 상태 데이터를 관리해주는 하나의 도구 (Angular, React, jQuery 에서도 사용 가능)","keywords":"","body":"Redux "},"03.-back-end/":{"url":"03.-back-end/","title":"03. Back End","keywords":"","body":"03. Back End SQL 인젝션 "},"03.-back-end/01.-java/":{"url":"03.-back-end/01.-java/","title":"01. Java","keywords":"","body":"01. Java Log4j Log Level TRACE 해당되는 내용에 대한 경로추적을 위해 사용 DEBUG 디버깅을 위한 목적 INFO 시스템 동작에 대한 정보를 제공 버그나 시스템 문제는 아니고, 단지 운영자에게 정보를 제공 WARN 현재 운영에는 문제가 없지만, 문제가 될 수 있는 사항 예외가 발생하지는 않았지만 해당 정보에 대해서 알려주어야 할 경우 ERROR 시스템 운영에 문제가 있을 만한 사항 보통 예외를 잡아서 정상처리한 경우 기록 FATAL 시스템 운여이 불가능한 경우 보통 예외가 발생하고 정상 처리 못한 경우 Layout %d : 로그의 기록시간을 출력 %p : 로깅의 레벨을 출력 %F : 로깅이 발생한 프로그램의 파일명을 출력 %M : 로깅이 발생한 메소드의 이름을 출력 %I : 로깅이 발생한 호출지의 정보를 출력 %L : 로깅이 발생한 호출지의 라인수를 출력 %t : 로깅이 발생한 Thread명을 출력 %c : 로깅이 발생한 카테고리를 출력 %C : 로깅이 발생한 클래스명을 출력 %m : 로그 메시지를 출력 %n : 개행 문자를 출력 %% : %를 출력 %r : 어플리케이션이 시작 이후부터 로깅이 발생한 시점까지의 시간(ms)을 출력 %x : 로깅이 발생한 Thread와 관련된 NDC(Nested diagnostic context)를 출력 %X : 로깅이 발생한 Thread와 관련된 MDC(Mapped diagnostic context)를 출력 Sample [%d{yyyy-MM-dd HH:mm}] %5p (%F:%L) %M: %m%n [%d{HH:mm:ss}] %-5p %C{1}.%M(%F:%L) - %m%n "},"03.-back-end/01.-java/01.-general/":{"url":"03.-back-end/01.-java/01.-general/","title":"01. General","keywords":"","body":"General 자료형 논리형 true false 중 하나를 값으로 갖으며, 조건식과 논리적 계산에 사용 boolean : 1 Byte 문자형 문자를 저장하는데 사용되며 변수당 하나의 문자만 저장 가능 char : 2 Byte 정수형 정수값을 저장하는데 사용되며 주로 int long 을 사용 byte : 1 Byte short : 2 Byte int : 4 Byte long : 8 Byte 실수형 실수 값을 저장하는데 사용한다. float : 4 Byte double : 8 Byte Process & Thread 프로세스와 스레드는 서로 밀접한 관계에 있으나 서로 다른 개체이다. Process 실행중인 프로세스 객체 CPU 시간이나 메모리 등의 시스템 자원이 할당되는 독립적인 개체 각 프로세스는 별도의 주소 공간에서 실행 되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없음 같은 메모리를 읽고 쓰는 프로세스는 생성 가능 프로세스간의 통신은 Pipe, Socket, File 등으로 통신한다. Thread 프로세스가 할당받은 자원을 이용하는 실행의 단위 프로세스와 같은 공간의 Stack 공간을 사용하며 여러 Thread 는 그 상태의 일부를 공유한다. Multi Thread 환경의 작업시에는 Therad 간의 자원 공유의 동기화 문제 에 신경을 써야 한다. Overloading & Overriding Overloading (오버로딩) 같은 이름의 함수를 여러개 정의하고 매개변수의 유형과 개수를 다르게 하여 다양한 유형의 호출에 응답 Overriding (오버라이딩) 상의 클래스가 가지고 있는 메소드를 하위 클래스가 재 정의 하여 사용하는 것어떤 메소드가 실행될지는 Dynamic Dispatch (동적 디스패치) 가 일어나며 확인 가능하다. Dispatch ? Static Dispatch : 컴파일 시점에서는 알 수 있다. Dynamic Dispatch : 런타임 순간에 알 수 있다. Boxing & Unboxing (박싱 & 언방식) Boxing : 값 (원시타입) 을 참조 형식으로 변환 UnBoxing : 참조 형식을 값 형식으로 변환 // Boxing Object a = 20; // UnBoxing int b = (int) a; Boxing 과정 graph TD; A[값 타입을 힙에 생성하기 위해 메모리를 힙 영역에 생성]-->B[값을 힙 영역에 할당된 메모리로 복사]; B-->C[참조할 변수에 할당된 메모리 주소를 할당]; Unboxing 과정 graph TD; A[Boxing 값인지 확인]-->B[Boxing 된 값이면 값유형의 변수에 복사]; B-->C[박싱한 메모리와 언박싱한 메모리 2개 존재]; 문제점 모든 객체가 값 형식으로 언박싱 될 수 없고, 이전에 박싱된 데이터에 한하여 언박싱이 가능하다. 또한 박싱된 데이터의 타입을 따라야 한다. 박싱 작업은 완전히 새로운 객체가 만들어져야 하며 이러한 작업은 할당 작업보다 최대 20배의 시간 이 걸린다고 한다 언박싱의 캐스팅 시간은 할당작업보다 4배이상 의 시간이 걸린다고 한다. Example - JAVA public class Sum { // 캐스팅 시간 4배, 박싱 작업 20배 느려짐 예제 public static void main (String[] args) { // long sum = 0L; Long sum = 0L; for (long i = 0; i Reference http://grayt.tistory.com/87 Compile Running 소스코드를 작성 Compiler 는 JAVA 소스코드를 이용하여 클래스 파일을 생성 컴파일된 파일은 JVM (Java Virtual Machine) 이 인식 가능한 바이너리 파일로 변환 JVM 은 클래스 파일의 바이너리 코드를 해석하여 프로그램을 실행 수행 결과가 컴퓨터에 반영 Access Modifier (접근 제어자) Java 에는 다음과 같은 접근 제어자가 있다.다음 순으로 접근을 허용한다. graph LR A[\"Private\"] --> B[\"Default\"] B --> C[\"Protected\"] C --> D[\"Public\"] Private 해당 클래스 내에서만 접근 가능하다. Default 접근 제어자를 따로 설정하지 않은 변수 혹은 메소드는 default 접근 제어자가 되어 해당 패키지 내에서만 접근 가능하다.해당 패키지 내에서만 접근 가능하다. Protected 동일패키지 내의 클래스에서 접근 가능하다. 해당 클래스를 상속 받은 외부 패키지의 클래스에서 접근 가능하다. Public 어떤 클래스에서라도 접근 가능하다. https://wikidocs.net/232 Finalize 객체가 소멸될때 호출되는 메소드사용이 권장 되지 않는다. "},"03.-back-end/01.-java/01.-general/jvm.html":{"url":"03.-back-end/01.-java/01.-general/jvm.html","title":"JVM","keywords":"","body":"JVM (Java Vertual Machine) 프로그램을 실행하기 위해 물리적 머신 (컴퓨터) 과 유사하게 만든 머신을 소프트웨어로 구현한 것 OS 별로 종류가 다른데 MS Window & Linux 등의 환경에서는 HotSpot VM, IBM AIX 의 경우에는 IBM J9 이 사용된다. 특징 자바의 가상머신으로 OS 에 종속적이지 않아 독립적으로 운영된다. GC (Garbage Collection) 은 사용자에 의해 명시되지 않으며 자동으로 메모리 관리가 된다. 프로그램이 실행되면 JVM 은 OS 로부터 프로그램이 필요로하는 메모리를 할당 받고, JVM 은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리 한다. JVM 외부 Java 로 작성한 코드는 Class Loader 가 컴파일된 Java Byte Code 를 Runtime Data Areas 에 로드하고 Excution Engine 이 Java Byte Code 를 실행 Class Loader (클래스 로더) 자바는 Runtime 시에 Class 를 로드하고 링크하는 Dynamic Loading 특징이 있다. 이 Dynamic Loading 특징을 담당하는 부분이 Class Loader 이다. Class Loader 는 로드된 클래스를 보관하는 Namespace 를 갖는데,이미 로드된 클래스 인지 확인하기 위하여 Namespace 에 보관된 FQCN 을 기준으로 클래스를 찾는다. FQCN (Fully Qualified Class Name) ? 클래스가 속한 패키지명을 모두 포함한 이름을 말한다.보통 java.lang.String s = new java.lang.String(); 과 같이 Alias Name (축약) 형이 아닌 패키지를 모두 포함한 경로Class Loader 에서는 비록 FQCN 이 같더라도 Namespace 가 다르면 다른 클래스로 간주 Class Loader 의 대표적인 역활은 사용자가 작성한 Java Byte Code 를 JVM 메모리상에 올려주는 역활을 한다. 클래스 로더 특징 클래스 로더는 다음과 같은 특징이 있다. Hierarchical (계층 구조) 클래스 로더끼리 부모 자식 관계를 이루어 계층 구조로 구성된다. 최 상의 클래스 로더는 부트스트랩 (Bootstrap Class Loader) 클래스 로더이다. Delegate Load Request (위임 모델) 계층 구조를 기반으로 클래스 로더끼리 로드를 위임하는 구조로 동작 한다. 클래스를 로드할 때 먼저 상위 클래스로더를 확인하여 존재하면 해당 클래스를 사용하고 없으면 요청 받은 클래스 로더가 클래스를 로드한다. Have Visibility Constraint (가시성) 하위 (자식) 클래스 로더는 상위 (부모) 클래스 로더를 찾을수 있지만 그 반대의 경우 (부모 -> 자식) 은 있을 수 없다. Cannot unload Classes (언로드 불가) 클래스 로더는 Unload 기능을 하지 않는다. (Unload 는 GC 자동으로 함) 클래스 로더 요청 처리 Class Loader 가 Class Load 를 요청 받으면, 아래 순서대로 검색을 한다. graph LR; A[\"Class Loader Cache\"]-->B[\"Parent Class Loader\"]; B-->C[\"Self\"]; Bootstrap Class Loader 까지 확인해도 없으면 요청 받은 클래스 로더가 파일 시스템에서 해당 클래스를 찾음 Reference https://m.blog.naver.com/PostView.nhn?blogId=choigohot&logNo=40192701035&proxyReferer=https%3A%2F%2Fwww.google.com%2F Runtime Data Areas (런타임 데이터 영역) Class Loader 에서 로드해준 데이터를 보관하여 애플리케이션을 수행한다.이 수행 작업시에 사용되는 저장 및 참조로 하는 메모리 영역이다. Method Area 모든 Thread 가 공유하는 메모리 영역 class interface method field static valuable byte code 등을 보관 임포트된 클래스가 로드되는 영역 Heap Area 프로그램 상에서 데이터를 저장하기 위해 동적으로 할당하여 사용 하는 메모리 영역 실제로 Runtime 시 동적으로 할당하여 사용하는 영역 자바 프로그램은 new 연산자를 사용하여 객체를 동적으로 생성 Method Area 에 로드된 클래스만 생성 가능 class 를 이용하여 instance 를 생성하면 해당 영역에 저장하여 사용 여러 Thread 가 이 영역을 공유 한다. 이 영역은 GC (Garbage Collector) 를 통해서만 메모리 해제가 가능하다. (GC 의 실제적인 대상) Method 영역이 클래스 정보를 참고하여 인스턴스를 생성하는 곳 이다. JVM Stack Area Method 가 호출될 때마다 Stack Frame 이라는 데이터 영역이 생성하여 구성 Method 에 사용되는 Thread 의 수행 정보를 Stack Frame 을 통해서 저장 Thread 가 시작될때 생성하며, Thread 별로 생성되기 때문에 다른 Thread 는 접근 할 수 없다. Method 의 정보, Local Valuable, Argument 등의 연산 중 발생되는 임시 데이터 등이 저장 된다. Method 수행 되는 동안만 사용되며 메소드의 수행이 끝나면 필요 없게 된다. Method 가 호출될 때는 필요로하는 변수를 Stack 에 저장 하고, Method 실행이 끝나면 Stack 을 반환 한다. 실행중인 Thread 에 따라 각각 구성 하게 된다. PC Register 실행중인 각 Thread 는 별도의 PC Register 를 가지며, 명령이 실행되면 현재 실행중인 명령의 주소를 유지한다. Native Method Stack JAVA 외의 언어로 작성된 네이티브 코드들을 위한 Stack JNI (Java Native Interface) 를 통하여 호출되는 C/C++ 등의 코드를 수행하기 위한 Stack 애플리케이션에서 Native Method 를 호출하게 되면 내부에 Stack Frame 을 생성하여 Push 한다. JNI 를 이용하여 JVM 내부에 영향을 주지 않기 위함 Native Method Stack 을 실행할때는 JVM 을 거치지 않고 바로 수행한다. Thread 마다 하나씩 생성 PC Register JVM Stack Native Method Stack Thread 끼리 공유 Heap Area Method Area Runtime Constant Pool Reference http://limkydev.tistory.com/51http://postitforhooney.tistory.com/entry/JavaJVM-JVM-이해를-통한-Java-작동원리-이해하기https://m.blog.naver.com/PostView.nhn?blogId=choigohot&logNo=40192701035&proxyReferer=https%3A%2F%2Fwww.google.com%2F https://medium.com/@lazysoul/jvm-이란-c142b01571f2 Excution Engine (실행 엔진) Class Loader 를 통하여 JVM 메모리상에 배치되어 있는 바이트 코드를 Excution Engine 에 의해 실행된다. Excution Engine 는 Java Byte Code 를 명령어 단위로 읽어서 실행한다. (CPU 가 기계어 & 명령어 를 하나씩 읽어서 실행하는 것 과 비슷하다 ) Java Byte Code 의 각 명령어는 1 Byte 의 OpCode 와 추가 피 연산자로 이루어져 있으며, 실행 엔진은 하나의 OpCode 를 가져와서 피 연산자와 함께 작업을 수행한 다음, OpCode 를 수행하는 식으로 동작 Java Byte Code 는 기계어에 가깝기 보다는 비교적 인간이 보기 편한 행태로 기술한다. Excution Engine 는 이와 같이 바이트 코드가 실제로 JVM 내부에서 기계가 실행할 수 있는 형태로 변경 최초의 JVM 은 Interpreter 방식으로 수행되었다. Interpreter (인터프리터) ? Byte Code 명령어를 하나씩 읽어서 해석한다.이로 인해 실행이 느리다는 단점을 가지고 있다. 이를 개선하기 위해 JIT Compiler 를 도입하여 개선을 한다. JIT (Just In Time) Compiler Interpreter 방식으로 실행하다 적절한(?) 시점에 Byte Code 전체를 Compile 하여 Native Code 로 변경하며 이후에는 해당 메서드를 더 이상 Interpreting 하지 않고 Native Code 로 직접 실행하는 방식 Native Code 를 실행하는 것이 명령어 단위로 Interpreting 하는것보다 빠르며, Native Code 는 내부 캐시에 보관하기 때문에 한번 Compile 한 코드는 계속 빠르게 수행 graph LR; A[Java Source Code]-->|Java Compiler|B[Byte Code] B-->|JIT Compiler|C[Native Code] JIT Compile 과정은 Byte Code 를 Interpreting 하는것보다 많은 비용이 발생하여, 만약 한번만 실행되는 코드라면 Compile 하지 않고 Interpreting 하는것이 훨씬 유리하다. 내부적으로 해당 Method 가 얼마나 자주 수행되고 체크하여 일정 정도의 수준이 넘을때만 Compile 수행 GC (Garbage Collector) GC 를 실행하기 위해 stop-the-world 을 이용하여 모든 애플리케이션 작업을 멈춘다.이 stop-the-world 를 실행하면 GC 를 실행하는 thread 를 제외한 나머지 thread 는 모두 작업을 멈춘다. GC 작업을 완료한 이후에는 중단됬던 작업을 다시 시작한다. JAVA 프로그램 코드에서는 메모리를 명시적으로 지정하여 해제하지 않는다.이는 Garbage Collector 의해 더 이상 필요없는 객체를 찾아 지우는 작업을 한다. 이 Garbage Collector 의 설계 원칙은 weak generational hypothesis 이라고 하는데 이 원칙은 다음과 같다. 대부분의 객체는 금방 접근 불가능한 상태 (unreachable) 상태가 된다. 오래된 객체에서 젊은 객체로서의 참조는 극히 드물다. 위 두 가설을 기반으로한 HotSpot VM 에서는 크게 2개의 물리적 공간을 나뉘었다.바로 아래와 같은 Old Generation Area, Young Generation Area 이다. Young Generation Area 새롭게 생성한 객체가 위치하는 공간 대부분의 객체가 금방 접근 불가 상태가 되기 때문에 많은 객체가 Young 에서 생성되었다가 사라진다 이 영역에서 객체가 사라질때 Minor GC 가 발생한다. Old Generation Area 접근 불가능 상태로 되지 않아 Young 영역에서 살아남은 객체가 여기로 복사된다. 대부분의 Young 영역보다 크게 할당하며, Young 영역 보다는 GC 가 적게 발생한다. 이 영역에서 객체가 사라질때 Major GC (혹은 Full GC) 가 발생한다. Permanent Generation Area 객체나 억류된 문자열 정보를 저장하는 곳 이 영역에서 객체가 사라질때 Major GC 가 발생한다. Old 영역에서 Young 영역 참조가 일어날때는 Card Table 이라는 영역을 사용한다. Young 영역 구성 Young 영역은 다음 3개의 영역으로 구성된다. Eden Area (1개) Suvivor Area (2개) 새로 생성한 대부분의 객체는 Edan 영역에 위치한다. Edan 영역에서 GC 가 한번 발생한 후 살아남은 객체는 Survivor 영역 중 하나로 이동된다. 하나의 Survivor 영역이 가득 차게되면 그중 살아남은 객체를 다른 Survivor 영역으로 이동하고 가득찬 Survivor 영역은 아무데이터도 없는 상태가 된다. 이 과정을 반복하며 살아남은 객체는 Old 영역으로 이동하게 된다. Survivor 영역 중 하나는 반드시 비어있는 상태로 남아 있어야 한다. 만약 두 Survivor 영역이 모두 데이터가 존재하거나, 두개의 Survivor 영역의 사용량이 0 이라면 시스템은 정상적인 상황이 아니다. HotSpot VM 의 메모리 할당 기술 Young 영역에는 객체의 이동이 빈번하기 때문에 개선된 메모리 할당 기술이 필요하다.다음은 HotSpot VM 에서 사용중인 2가지의 메모리 할당 기술이다. bump-the-pointer Eden 영역에 할당된 마지막 객체를 추적한다. 마지막 객체는 TOP 에 위치하고 있기 때문에 삽입하려는 객체의 크기가 Eden 영역에 넣기에 적당한지 확인하여 추가한다. 새로운 객체를 생성할때 마지막에 추가된 객체만 점검하면 되므로 매우 빠르게 메모리 할당이 이루어진다. TLABs (Thread Local Allocation Buffers) Multi Thread 환경에서 Tread-Safe 하기 위해서 Edan 영역에 Lock 이 발생 할수 밖에 없는데 이를 해결하기 위해서 HotSpot VM 에서 지원하는 TLABs 기술이 있다. Old 영역의 GC Old 영역은 데이터가 가득차면 GC 를 실행한다.다음 GC는 JDK 7 기준의 5가지 방법이다. Serial GC CPU 코어 개수가 적을 때 적합 Parallel GC 메모리와 CPU 코어 개수가 많을 때 유리 Parallel Old GC (Parallel Compacting GC) Concurrent Mark & Sweep GC (CMS) 애플리케이션 응답이 중요한 경우 사용 (Low Latency GC) 다른 GC 에 비해 메모리와 CPU 를 더 많이 사용 다른 GC 에 비해 산재된 메모리가 많을수 있기 때문에 stop-the-world 시간이 더 길다. G1 (Garbage First) GC 가장 최신의 가장 성능이 좋은 GC (JDK 7 이상) Reference https://d2.naver.com/helloworld/1329 "},"03.-back-end/01.-java/01.-general/solid.html":{"url":"03.-back-end/01.-java/01.-general/solid.html","title":"Solid","keywords":"","body":"Solid 객체지향 4대 특성인 캡슐화, 상속, 추상화, 다형성 등을 이용하여 객체지향 프로그래밍 셜계를 도와주는 원칙들이 있다.이를 SOLID 원칙들이라 하며 자기 자신의 클래스의 응집도를 높이고, 타 클래스의 결합도를 낮추는 High-Cohesion - Loose Coupling 원칙을 객체 지향관점에서 도입한것이다. SOLID 5대 원칙 (객체 지향 설계 5원칙) SRP (Single Reponsibility Principle : 단일 책임의 원칙) OCP (Open Closed Principle : 개방 폐쇄 원칙) LSP (Liskov Substitution Principle : 리스코프 치환 원칙) ISP (Interface Segregation Principle : 인터페이스 분리 원칙) DIP (Dependency Inversion Principle : 의존 역전 원칙) SRP (Single Reponsibility Principle : 단일 책임의 원칙) 작성된 클래스는 하나의 기능만 가지며 클래스가 제공하는 모든 서비스는 그 하나의 책임을 수행하는데 집중 되어야 한다는것 리팩토링 (Refactoring) 을 통하여 해당 책임을 최상의 상태로 분배 OCP (Open Closed Principle : 개방 폐쇄 원칙) 소프트웨어의 구성요소 (컴포넌트, 클래스, 모듈, 함수) 는 확장에는 열려 있고, 변경에는 닫혀 있어야 한다는 의미이다.기존의 구성요소는 수정이 일어나지 말아야 하며, 기존의 구소요소를 쉽게 확장하여 재 사용 가능해야 한다는 뜻이다. 확장 될것과 불변의 속성을 엄격히 구분한다. 두 모듈이 만나는 지점에 인터페이스를 정의한다. 구현에 의존하기보다 정의한 인터페이스에 의존하도록 코드를 작성한다. LSP (Liskov Substitution Principle : 리스코프 치환 원칙) 서브타입은 언제나 기반 타입과 호환될 수 있어야 한다. 하위 클래스가 상위 클래스의 역할을 대신할 때 논리적으로 맞아 떨어져야 한다. ISP (Interface Segregation Principle : 인터페이스 분리 원칙) 최소한의 의미에 맞는 인터페이스만 구현해야 한다. 클래스 인터페이스를 통한 분리객체 인터페이스를 통한 분리 DIP (Dependency Inversion Principle : 의존 역전 원칙) 하위 레벨모듈의 변경이 상위 레벨 모듈의 변경을 요구하는 역전현상 Reference http://www.nextree.co.kr/p6960/http://limkydev.tistory.com/77http://choipattern.blogspot.com/2013/08/solid.html "},"03.-back-end/01.-java/02.-references/":{"url":"03.-back-end/01.-java/02.-references/","title":"02. Reference","keywords":"","body":""},"03.-back-end/01.-java/02.-references/collection.html":{"url":"03.-back-end/01.-java/02.-references/collection.html","title":"Collection","keywords":"","body":"Collection Collection 인터페이스를 상속 받은 구현체 List 와 Set 을 기준으로 나뉜다. graph LR A[\"Collection\"] --> B[\"List\"] B --> D[\"Linked List\"] B --> E[\"Stack\"] B --> F[\"Array List\"] B --> G[\"Vector\"] A --> C[\"SET\"] C --> H[\"Hash Set\"] C --> I[\"Sorted Set\"] I --> J[\"Tree Set\"] List 순서가 있는 Collectaion (삽입된 순서)Data 를 중복해서 포함할 수 있다. Linked List Stack 후입선출 (LIFO : Last-In First-Out) 구조로 되어 있다. ArrayList 동기화를 보장하지 않는다. 배열의 동적 메모리 증가 기능을 구현한 클래스 Vector 자동으로 동기화를 보장해 준다. ArrayList 의 동기화가 보장되도록 최적화한 클래스 JDK 5.0 이후부터 Auto Boxing / UnBoxing 기능을 지원 Tree Set 정렬 기능을 지원 (데이터들이 자동으로 오름차순으로 정렬) AutoBoxing 기본 데이터 타입을 Wrapper 클래스형의 객체로 자동 변환해주는 기능 Set 집합적인 개념의 Collection순서의 의미가 없다.Data 를 중복해서 포함할 수 없다. Hash Set Hash 기법을 사용하지만 Set 인터페이스를 구현하고 있다. Sorted Set 정렬 기능을 지원함 Map Key 와 Value 의 형태로 데이터를 관리한다. HashMap 동기화 보장이 안된다. Hashtable 동기화 보장이 된다. (멀티스레드 환경에서 안정적) TreeMap 정렬 기능을 지원함 graph LR A[\"Map\"] --> B[\"HashMap\"] A --> C[\"Hashtable\"] A --> D[\"Sorted Map\"] D --> E[\"Tree Map\"] Referencehttp://withwani.tistory.com/150 "},"03.-back-end/01.-java/03.-performance/":{"url":"03.-back-end/01.-java/03.-performance/","title":"03. Performance","keywords":"","body":"Performance String / StringBuffer / StringBuilder 의 사용 문자열을 더하는 식에는 string 보다는 stringBuffer 나 stringBuilder 을 사용해야 한다. string 은 새로운 값을 할당할 때마다 새로 생성되기 때문 (클래스의 메모리 참조 주소가 바뀜) stringBuffer 나 stringBuilder 는 값을 메모리에 append 하는 방식으로 클래스를 별도로 생성하지 않는다. stringBuilder 는 변경 가능한 문자열로 synchronization 이 적용되지 않는다. stringBuffer 는 멀티쓰레드 환경에서 안정적 이다. "},"03.-back-end/02.-server/":{"url":"03.-back-end/02.-server/","title":"02. Server","keywords":"","body":"02. Server "},"03.-back-end/02.-server/linux.html":{"url":"03.-back-end/02.-server/linux.html","title":"Linux","keywords":"","body":"Linux nslookup nslookup 명령어는 네임 서버 관련 조회를 할 수 있는 명령어이다.서버의 네트워크가 살아있는지 확인하는 용도로 사용한다. $ nslookup IP $ nslookup DOMAIN dig DIG (Domain Information Groper) 는 nslookup 과 동일한 기능이지만 더욱 상세한 출력이 가능합니다. 특정 도메인 확인 $ dig google.com 특정 네임서버를 통한 도메인 확인 $ dig @8.8.8.8 google.com 도메인 추적 확인 $ dig google.com +trace 참고 자료https://www.codns.com/b/B05-110 telnet 서버 네트워크가 살아있는지 확인하는 용도로 많이 사용 한다. $ telnet IP [PORT] $ telnet DOMAIN [PORT] service 리눅스 상에 서비스로 등록되어 있는 목록을 가져온다. # service --status-all 리눅스 상에 서비스를 기동 혹은 중지 시킨다. # service SERVICE_NAME start # service SERVICE_NAME restart # service SERVICE_NAME stop netstat 포트별 서비스 목록 # netstat -atlpvn # netstat -tnlp State LISTENING 서비스 대기중 ESTABLISHED 다른 컴퓨터와 연결된 상태 CLOSED 연결이 종료되어 있는 상태 TIME WAIT 연결은 종료 되었지만 당분간은 소켓은 열어놓은 상태 Options -a --all 모든 소켓을 보기 -c --continuous 현재의 실행 명령을 매 초마다 실행 -e --extend 확장 정보 추가 -g --groups 멀티캐스트에 대한 그룹별 정보를 보여줌 (IPv4/IPv6) -i --interface 인터페이스별 통계값 -n --numberic 도메인을 주소를 읽지 않고 숫자로 출력한다. 아래 3개의 명령어가 합쳐진 형태이다. --numberic-hosts : 호스트 부분을 IP 로 출력 --numberic-ports : 포트 부분을 숫자로 출력 --numberic-users : 유저 부분을 숫자로 출력 (UID) -o --timers 연결 대기 시간 표기 -p --program PID 와 사용중인 프로그램명을 표시 -r --route 라우팅 테이블 보기 -s --statistics 프로토콜 요약 정보 -t --tcp TCP 프로토콜 보기 -u --udp UDP 프로토콜 보기 -v 버전 보기 -w --row RAW 프로토콜 보기 -A 프로토콜별 보기 -M 마스커 레이딩 정보 표시 "},"03.-back-end/02.-server/nginx/":{"url":"03.-back-end/02.-server/nginx/","title":"NGINX","keywords":"","body":"NGINX 기존 Apache 랑 차이점 apache 요청마다 스레드 혹은 프로세스 생성 및 처리 nginx 요청마다 비동기 이벤트를 발생시켜 처리 proxy_pass /etc/nginx/sites-available/default 경로를 다음과 같이 수정한다. 이전 파일은 백업 한다. server { listen 80; server_name localhost; location / { proxy_pass http://localhost:8080; } } "},"03.-back-end/02.-server/nginx/cli.html":{"url":"03.-back-end/02.-server/nginx/cli.html","title":"CLI","keywords":"","body":"CLI Installation Package 를 이용한 nginx 설치 설치 환경 Ubuntu 18.0.4 LTS $ apt-get update $ apt-get install nginx -y 설치 확인 $ nginx -v Command Service Start $ sudo service nginx start $ sudo systemctl start nginx $ sudo /etc/init.d/nginx start Service Restart $ sudo service nginx restart $ sudo systemctl restart nginx $ sudo /etc/init.d/nginx restart Service Stop $ sudo service nginx stop $ sudo systemctl stop nginx $ sudo /etc/init.d/nginx stop Service Status $ sudo service nginx status $ sudo systemctl status nginx Service Status Reload 설정파일을 변경한 후 적용시 사용 $ sudo service nginx reload $ sudo systemctl reload nginx $ sudo nginx -s reload Configuration Check $ sudo nginx -t "},"03.-back-end/03.-network/":{"url":"03.-back-end/03.-network/","title":"03. Network","keywords":"","body":"03. Network TCP/UDP 포트 목록 기본적으로 권고되는 기본포트는 다음과 같으며 이는 IANA 의 권고안으로 구성된다.자주 사용되는 포트는 다음과 같다. PORT 설명 TCP UDP 20 FTP (파일 전송 프로토콜) - 데이터 포트 O 21 FTP - 제어포트 O 22 SSH (다른 FTP 프로그램의 의해서 SFTP의 기본 포트로 설정되는 경우가 있어 충돌이 난다) O 23 Telnet O 25 SMTP - 이메일 전송에 사용 O 80 HTTP - 웹 페이지 전송 O 443 HTTPS - SSL 위의 HTTP의 암호화 전송 O 990 SSL 위의 FTP의 암호화 전송 O "},"03.-back-end/03.-network/http/":{"url":"03.-back-end/03.-network/http/","title":"HTTP","keywords":"","body":"HTTP HTTP Header Request Header 클라이언트 브라우저에서 HTTP 프로토콜을 이용하여 요청 정보를 웹 서버로 전송할 때 HTTP 요청 헤더에 부가적인 정보를 담아 전송한다. Accept 클라이언트가 처리하는 미디어 타입 Accept-encoding 클라이언트가 해석할 수 있는 인코딩 방식 Accept-language 클라이언트가 지원하는 언어 Connection 클라이언트와 서버의 연결 방식 keep-alive : 클라이언트와 접속 유지 close : 클라이언트와 접속 중단 Host 호스트 이름 URI 와 PORT 번호 정보 User-agent 클라이언트 브라우저 정보 Response Header 서버가 HTTP 프로토콜을 이용하여 클라이언트의 요청에 대해 응답할 때 부가적인 정보를 응답 헤더에 담아 전송한다. Connection 클라이언트와 서버의 연결 방식 설정 keep-alive : 클라이언트와 접속 유지 close : 클라이언트와 접속 중단 Content-Length 요청한 파일의 데이터 길이 Content-Type 헤더 응답 문서의 mime 타입 Date 현재 일시를 GMT 형식으로 지정 Server 웹 서버 정보 CORS 관련으로 Access-Control-Allow-Origin: * 으로 설정되면 도메인 구분없이 XHR 호출이 가능해진다. Keep-alive 관련 디바이스 간의 커넥션을 유지하는 기법 으로 TCP 와 HTTP 가 전혀 다르다. TCP 는 OS가 제어 하고, HTTP 는 웹 서버가 제어 한다. HTTP 1.1 이상에서 지원되는 스팩으로 헤더에 설정 하면 된다. max 요청수 와 유효시간(timeout) 으로 구성된다. Timeout 종류 Connection Timeout Connection 을 구성하는데 소요되는 시간 Read Timeout Server 에서 데이터를 완전히 받을때 까지 걸리는 시간 MIME 서버가 클라이언트에게 전송되는 문서에 대한 유형을 지칭하는 타입 Syntax [파일의종류]/[파일타입] Type List text 텍스트 파일 text/plain, text/html, text/css, text/javascript multipart 이미지 파일 (비디오 제외) audio/midi, audio/mpeg, audio/webm, audio/ogg, audio/wav audio 오디오 파일 audio/midi, audio/mpeg, audio/webm, audio/ogg, audio/wav video 비디오 파일 video/webm, video/ogg application 모든 바이너리 타입 application/octet-stream, application/pkcs12, application/vnd.mspowerpoint, application/xhtml+xml, application/xml, application/pdf Cookie & Session & Cache HTTP 프로토콜의 상태 유지를 하기 위해 Server 가 Client 를 식별할 수 있도록 사용하는 방식 공통점 사용자에게 빠르게 서비스를 전달하기 위해 데이터를 저장해서 사용한다. 차이점 Cookie 클라이언트에 저장되는 키와 값이 들어있는 작은 데이터 파일 (하나당 4KB 이하) 이름, 값, 만료날짜 (쿠키의 저장시간), 경로정보 등이 포함되어 있다. 사용자가 임의로 쿠키 데이터를 저장, 수정, 삭제할 수 있다. HTTP 전송시에 요청 헤더에 쿠키 값이 들어 있어 쿠키의 자료량 (데이터 사이즈) 이 큰 경우오버헤드로 인한 웹서버 에러가 발생 할 수 있다. Session 서버에서 사용하는 클라이언트 인증 정보이다. 서버는 접속 클라이언트 별로 세션을 생성해서 세션의 해당하는 쿠키 (Session ID) 를 클라이언트에게 생성하게 하고 이 클라이언트는 서버에 접속할 때마다 해당 쿠키의 값 (Session ID) 을 서버에 전송하여 세션을 유지하게 한다. Cache 정적 자원들을 안정적으로 서비스하기 위해 데이터를 미리 저장해두고 제공하는 방식 프록시 (Proxy) 서버에서 제공 Reference http://blog.kurien.co.kr/544http://brownbears.tistory.com/34http://asfirstalways.tistory.com/68 "},"03.-back-end/03.-network/http/http2.0.html":{"url":"03.-back-end/03.-network/http/http2.0.html","title":"HTTP 2.0","keywords":"","body":"HTTP 2.0 HTTP1 의 요청 방식 HTTP1 에서는 앞에서 날렷던 요청의 응답을 받아야만 다음 요청이 처리될 수 있다. sequenceDiagram Note over Client, Server : Establish Connection Client ->> + Server : Request Note right of Server: Blocked Server ->> - Client : Response Note over Client, Server : Close Connection Note over Client, Server : Establish Connection Client ->> + Server : Request Note right of Server: Blocked Server ->> - Client : Response Note over Client, Server : Close Connection 이러한 현상을 해결 하기위해 지속 커넥션 (Persistent Connection) 이라는 개념과 HTTP 파이프 라이닝 (Pipelining) 이라는 개념이 들어갔다.커넥션을 재사용할 수 있고, Request 를 미리 여러개 서버로 요청할 수 있게 되었다. 하지만 근본적으로 Request 보낸 순서대로 Response 를 받을수 있다는 점에서는 문제해결이 어려워 보인다. HOL (Head-of-Line Blocking) 의 문제점 만약 처음에 요청한 Request 에 문제가 있어 Response 가 늦어지면 2번째, 3번째에 요청한 Request 의 Response 도 늦어지는 문제점이 발생한다. gantt title Head-Of-Line Blocking dateFormat YYYY-MM-DD section HTTP Request 1 : crit, 2000-01-01 , 12d Request 2 : 6d Request 3 : 6d 도메인 샤딩 HOL 과 같은 문제들을 해결하기 위하여 리소스를 도메인 별로 분리해서 자원을 받는 방법도메인별로 리소스를 병렬적으로 동시에 받을수 있다. gantt title Domain Sharding dateFormat YYYY-MM-DD section Request HTML index.html : html, 2000-01-01 , 8d section A Domain style_1.css : css, after html, 6d style_2.css : after html, 6d style_3.css : after css, 6d style_4.css : after css, 6d section B Domain resource_1.js : js , after html, 6d resource_2.js : after html, 6d resource_3.js : after js, 6d resource_4.js : after js, 6d 하지만 하나의 도메인별 브라우저에서 받을수 있는 커넥션의 제한 이나 DNS Lookup 과정과 TCP Handshake 과정에서 소요되는 시간 때문에 오히려 부작용 발생 가능성이 있다. 브라우저당 도메인별 리소스 다운 제한은 보통 6 ~ 8 개정도 이며 iframe 은 제외이다. 그 외 방법들 HTTP 1.1 에서는 다음과 같은 방법을 통해서도 성능개선을 시도하였다. HTTP 요청 최소화 큰 이미지를 틍으로 요청후 CSS 로 잘게 잘라서 사용 BASE64 인코딩된 이미지를 요청해서 사용 소스 압축 HTML 의 gzip 압축 전송 JS, CSS 의 소스 압축 HTTP 2.0 의 다른점 바이너리로 인코딩된 데이터 전송 기존의 텍스트 기반의 데이터를 바이너리 포맷의 데이터로 사용하게 되어파싱이 더 빠르고 오류 발생 가능성이 적으며 하나의 플레인 데이터를 프레임 단위로 나눠서 관리 및 전송할 수 있다. HTTP 2.0 은 Frame 과 Stream 이라는 개념이 적용 되었다. HTTP 1.x 시절에는 요청 (Request) 과 응답 (Response) 으로 명확히 구분되었다. Frame HTTP2 통신에서 데이터를 주고 받을수 있는 가장 작은 단위의 데이터 헤더 프레임, 데이터 프레임으로 구성 Stream Server 와 Client 사이의 양방향으로 데이터를 주고 받는 한개 이상의 메세지 를 의미한다. 스트림 = 메세지 + 메세지 + 메세지 + 메세지 + 메세지 + 메세지 + ...메세지 = 프레임 + 프레임 + 프레임 + 프레임 + 프레임 + 프레임 + ... 우선순위 설정 상대적으로 중요한 리소스를 먼저 다운로드 받게 끔 전송 스트림의 우선순위 설정이 가능하다. Server Push 요청한 클라이언트에게 서버가 알아서 필요한 리소스를 찾아서 내려준다. gantt title Domain Sharding dateFormat YYYY-MM-DD section Request HTML index.html : html, 2000-01-01 , 8d section Server Push style_1.css : after html, 6d style_2.css : after html, 6d style_3.css : after html, 6d style_4.css : after html, 6d resource_1.js : after html, 6d resource_2.js : after html, 6d resource_3.js : after html, 6d resource_4.js : after html, 6d 하지만 브라우저가 캐싱된 데이터 나 필요없는 리소스 데이터 는 자원의 낭비를 초래할 수 있다. 헤더의 압축 HTTP2 의 Header 는 Header Table 로 관리 되어 이전 요청에서 중복으로 선언된 헤더는 인덱스 값만 전송하여 데이터를 최소화 한다. 적용 방법 TSL / SSH 인증서 필요 웹서버의 세팅 고려사항 일부 환경에 대해서는 효율이 떨어져 적용 환경에 따른 고려가 필요하다. HTTP 2.0 효율이 낮은 경우 HTTP 1.1 보다 성능적으로는 우수하지만 적용하였을때의 아래와 같은 상황일 경우 성능적 이점이 차이가 없는 경우도 있다. HTTP 만 사용하는 경우 SSL 핸드셰이크 시간이 추가적으로 필요하여 추가 시간 소요 도메인이 많은 경우 도메인별로 동작하므로 도메인별로 커넥션이 필요로 하다 이에 따른 시간적 효율이 떨어진다. HTTP 가 병목 현상이 없는 경우 RTT (Round-Trip Dealy Time : 메세지를 원격에 보내고 그것이 돌아오는 응답시간 - 레이턴시) 가 작은 경우 레이턴시가 큰 경우에만 더 큰 효율을 얻을수 있기 때문에 RTT 가 매우 작은 경우에는 이점이 없다. 페이지 내의 리소스가 적은 경우 6개 이하의 리소스를 가진다면 커넥션 재사용의 가치가 떨어진다. 일부 클라이언트 브라우저에 의해서 지원 가능성이 상이하여 확인이 필요하다. 지원 가능 브라우저 IE11 (Win10 ver) IE Edge Chrome IOS Chrome Firefox Opera 기타 브라우저 Reference https://d2.naver.com/helloworld/140351http://americanopeople.tistory.com/115https://www.popit.kr/나만-모르고-있던-http2/https://kinsta.com/learn/what-is-http2/ "},"03.-back-end/04.-rdbms/":{"url":"03.-back-end/04.-rdbms/","title":"04. Database","keywords":"","body":"04. Database SQL Injection 코드 인젝션의 한 기법으로 클라이언트의 입력값을 조작하여 서버의 데이터베이스를 공격하는 방식을 말한다. 방어 방법 권한으로 제한하는 방법 Query String 을 실행을 권한에 따라 제한할 수 있도록 한다. 입력값 검증 정규식 혹은 유효값의 vaildation 확인을 한다. Prepared Statement (저장 프로시저) 사용 현존하는 가장 좋은 방법으로 사용전에 일부 컴파일 되어 실행된다.Query 에 미리 형식을 지정하는 것으로 지정된 형식의 Query 형식이 아니면 실행되지 않는다. try{ String uId = \"admin\"; String query = \"SELECT * FROM user_info WHERE uId= ?\" stmt = conn.prepareStatement(query); stmt.setString(1, uId); ResultSet rs = stmt.executeQuery(); while(rs.netxt()) { /* statement */ } } catch () { /* statement */ } finally { /* statement */ } "},"03.-back-end/04.-rdbms/01.redis.html":{"url":"03.-back-end/04.-rdbms/01.redis.html","title":"01.Redis","summary":"인메모리 기반의 데이터 베이스","keywords":"","body":"01.Redis 설치하기 1. 의존 라이브러리 설치 $ sudo apt-get update $ sudo apt-get install build-essential tcl build-essential C, C++ 컴파일 환경을 구성 가능하게 한다. gcc, make 를 한번에 설치한다. tcl Tool Command Language 설치한 응용 프로그램을 확장하는 것을 돕는 프로그램 언어 2. 소스 다운로드 및 압축 해제 $ mkdir /tmp/src $ cd /tmp/src $ curl -O http://download.redis.io/redis-stable.tar.gz $ tar xvfz redis-stable.tar.gz $ cd redsi-stable 3. 컴파일 $ make $ make test $ make install 4. 실행 $ sudo systemctl start redis $ sudo systemctl status redis Issue 설치 이후에 redis 서버가 기동이 불가함해당 소스파일 경로로 redis-server.sh 로 기동이후 redis-cli 사용 가능함 추후 서비스로 등록하여 데몬으로 기동 가능하게 설정 해야 함 참고자료https://hanee24.github.io/2018/01/05/how-to-install-redis-on-ubuntu-16-04/ "},"03.-back-end/05.-framework/":{"url":"03.-back-end/05.-framework/","title":"05. Framework","keywords":"","body":"05. Framework "},"03.-back-end/05.-framework/spring/":{"url":"03.-back-end/05.-framework/spring/","title":"Spring","keywords":"","body":"Spring Framework vs Library 가장 크게는 제어의 흐름이 다르며Framework 는 사용자의 코드가 프레임워크에 사용되는 것이고Library 는 사용자에 코드에 의해 소비되는 것이다. Framework 는 IoC 개념이 적용되어야 하며 이는 특정의 프로세스를 프레임워크가 처리 가능하도록 제어를 넘김으로써 클라이언트 코드가 라이브러리의 메소드를 호출해서 사용하는 것 을 의미합니다. AOP (Aspect Oriented Programming : 관점 지향 프로그래밍) 어플리케이션 전체에 사용되는 기능을 재사용 하도록 지원 하도록 도와주는 것 관심의 분리 (Seperation of Concerns) 를 통하여 핵심 관심 사항 (입금, 출금, 이체) 에 집중 하는것이다. 장점 중복되는 코드 제거 효율적인 유지보수 높은 생산성 재활용성 극대화 유연한 변화 수용 IoC (Inversion of Control : 제어의 역전) 프로그램의 제어의 흐름 구조가 바뀌는 것이다. 일반적인 객체의 흐름은 다음과 같다. 객체 생성 의존성 객체 생성 (클래스 내부) 의존성 객체 메소드 호출 하지만 스프링 내부에서는 다음과 같은 순서로 생성 및 실행된다. 객체 생성 의존성 객체 주입 (스프링에게 위임하여 만들어놓은 객체) 의존성 객체 메소드 호출 스프링이 모든 의존성 객체를 스프링이 실행될때 다 만들어 주고 필요한 곳에 주입시켜줌으로써Bean 들은 싱글턴 패턴의 특징 을 가진다. 제어의 흐름을 사용자가 컨트롤 하는것이 아닌 스프링에게 맏겨 작업을 처리(스프링이 처리) 하게 된다. 사용자는 자신이 만든 객체가 어디에 사용되는지 알 수 없고 제어 권한을 위임받는 특별한 객체에 의해서 만들어지고 사용된다. 이는 다음 두가지의 구현 방법 으로 설명 된다. DL (Dependency Lookup : 의존성 검색) 저장소에 저장되어 있는 빈 (Bean) 에 접근하기 위해 개발자들이 컨테이너에서 제공하는 API 를 이용하여 사용하고자 빈을 Lookup 하는 것 DI (Dependency Injection : 의존성 주입) 각 계층 사이와 각 클래스 사이의 필요로 하는 의존 관계를 컨테이너가 자동으로 연결해 주는것 DL 을 사용시 컨테이너의 종속성이 증가하여, 이를 줄이기 위해서 DI 를 사용 public class Parent { private Child child; public void setChild(Child child) { this.child = child; } } 스프링에서는 객체의 생성과 소멸에 관련된 작업을 자동으로 수행해 주는데 객체가 생성되는곳을 Bean Container 라고 한다. 스프링에서는 객체를 Bean 이라고 부르며, 프로젝트가 실행될 때 사용자가 Bean 으로 관리하는 객체들을 자동으로 생성해 준다. 스프링에서 실행할 때 생성했던 Bean 을 주입시켜주는 과정을 DI 라고 한다. 용어 정리 Bean 스프링 (정확히는 스프링 컨테이너) 에서 생성 및 및 관계 설정, 사용등을 제어해주는 객체 Bean Factory 스프링이 IoC 를 담당하는 핵심 컨테이너 빈을 등록/생성/조회/반환/관리 하는 기능으로 bean factory 와 같지만 여기에 spring 의 각종 부가서비스를 추가로 제공해야 한다. Application Context bean factory 를 확장한 IoC 컨테이너 Container (IoC Container) 객체를 관리하는 컨테이너로써 컨테이너에 객체를 담아두고 필요할 때에 컨테이너에서 객체를 가져와 사용할 수 있도록 한다. IoC 방식으로 Bean 을 관리한다는 의미에서 Bean Factory 나 Application Context 를 가르킨다. Referencehttp://javaslave.tistory.com/48 Spring Bean Life Cycle graph TD; A[\"빈 설정 파일 정보 초기화\"] --> B[\"POJO 빈 초기화 상태\"] B --> C[\"POJO 빈 준비 상태\"] C --> D[\"POJO 빈 소멸 상태\"] POJO 초기화 과정 Spring Framework 는 먼저 Bean 설정파일의 POJO 빈을 Instance 화 하지 않은 상태로 Bean 설정 파일의 정보를 초기화 한다. 빈 설정 파일의 정보를 초기화 하면서 XML DTD 에 대하여 유효한지 체크한다. Bean Instance 를 생성하면서 의존 관계에 있는 Bean 이 존재하는지 여부를 체크한다. 의존 관계가 없는 Bean 인 경우 초기화가 실패 한다. 의존 관계가 있는 빈의 체크가 완료되면 setter Method 를 호출하거나 생성자의 인자로 실질적인 값을 추가하거나 다른 Bean 에 대한 Reference 로 전달한다. Application Context 를 이용하여 초기화를 실행한다. 생성한 Bean 이 BeanNameAware Instance 이면 setBeanName() Method 를 호출한다. 생성한 Bean 이 BeanFactoryAware Instance 이면 setBeanFactory() Method 를 호출한다. 생성한 Bean 이 ApplicationContextAware Instance 이면 setApplicationContext() Method 를 호출한다. 생성한 Bean 이 InitalizingBean 인스턴스이면 afterProperties() Method 를 호출한다. 생성한 Bean 의 설정파일에 init-method 가 설정되어 있다면 init-method 에 해당하는 Method 를 호출한다. 종료 Method 를 호출하는 과정 생성한 Bean 이 DisposableBean Instance 이면 distory() Method 를 호출한다. 생성한 Bean 설정파일에 distory-method 가 설정되어 있으면 destory-method 에 해당하는 메소드를 호출한다. Bean Life Cycle 을 커스터마이징 하여 제어 할 수 있다. Spring Boot 기동 Linux Deploy Shell Script 리눅스 환경에서 쉽게 관리를 위해 Shell Script 형태로 만들어 두어 관리한다. start.sh 앱을 시작하고 해당 PID 를 파일에 저장한다. #!/bin/bash java -jar myapp.jar & echo $! > ./pid.file & stop.sh 저장된 PID 를 사용하여 앱을 중지 한다. #!/bin/bash kill $(cat ./pid.file) 참고 경로https://code.i-harness.com/ko/q/195154c Gradle 로 Spring Boot 기동 # gradle bootRun Reference http://isstory83.tistory.com/m/91 "},"03.-back-end/05.-framework/spring/gradle.html":{"url":"03.-back-end/05.-framework/spring/gradle.html","title":"Gradle","keywords":"","body":"Gradle Gradle 설치 Mac # brew gradle Ubuntu # apt-get install gradle Gradle 빌드 # gradle build "},"03.-back-end/05.-framework/hibernate.html":{"url":"03.-back-end/05.-framework/hibernate.html","title":"Hibernate","summary":"Boss 에서 개발한 ORM (Object Relational Mapping) 프레임워크 이다.","keywords":"","body":"Hibernate ORM (Object Relational Mapping) RDBMS 테이블을 객체지향적으로 사용하기 위한 기술이다.RDBMS 는 객체지향적 접근이 쉽지 않기 때문에 ORM 을 사용하여 객체와 RDBMS 사이를 객체 지향적으로 다루기 위한 기술이다. JPA (Java Persistence API) ORM 의 표준 기술로 Hibernate, OpenJPA, EclipseLink, TopLink Essentials 과 같은 구현체가 있고, 이들의 대한 표준 인터페이스 이다. 장점 객체지향적으로 개발 및 데이터를 관리 할 수 있기 때문에 비지니스 로직에 집중할 수 있다. 테이블의 생성, 변경, 관리가 쉽다. 빠른 개발이 가능하다. DB 에 의존적이지 않다. MySQL, Oracle, Sysbase, Derby, PostgreSQL 등등의 데이터 베이스 지원 POJO 기반의 모델의 지원 단점 객체지향을 이해하고 개발 해야 하는 만큼 러닝커브가 높다. 성능상의 문제가 있을수 있다. "},"03.-back-end/06.-devops/":{"url":"03.-back-end/06.-devops/","title":"06. DevOps","keywords":"","body":"06. DevOps "},"03.-back-end/06.-devops/docker/":{"url":"03.-back-end/06.-devops/docker/","title":"Docker","keywords":"","body":"Docker Docker 란? 호스트 OS 위에 게스트 OS 전체를 가상화 시키는 기존 방식과는 달리CPU 의 가상화 기술 (HVM) 을 이용한 KVM (Kernel-based Virtual Machine) 과 반가상화 (Paravirtualization) 방식의 Xen 방식으로 구성된다.Docker 는 프로세스를 격리 시켜 하나의 독립된 OS 처럼 가상화 시키는 방법으로 사용된다. Docker 에서는 이미지를 가지고 컨테이너로 구성하여 사용한다. -이미지는 변하지 않으며 (Immutable) 특성을 가진다.컨테이너는 이미지를 실행한 상태로 추가되거나 변경되는 값은 컨테이너에 저장된다._ 참고 자료 초보를 위한 도커 안내서 가장 빨리 만나는 Docker "},"03.-back-end/06.-devops/docker/cli.html":{"url":"03.-back-end/06.-devops/docker/cli.html","title":"CLI","keywords":"","body":"CLI Version 버전 확인 (version) $ docker version $ docker --version $ docker version 정보 확인 (info) $ docker info Image 이미지 찾기 (search) $ docker search IMAGE 이미지 다운 (pull) $ docker pull IMAGE[:TAG] 이미지 목록 (ls) $ docker image ls 이미지 삭제 (rmi) $ docker rmi IMAGE[:TAG] Container 컨테이너 생성 (run) $ docker run [OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARG...] $ docker run -i -t -d -p 80:80 --name ubuntu_container ubuntu /bin/bash ubuntu 이미지를 컨테이너로 생성 ubuntu 이미지를 컨테이너로 생성 -i(interactive) 표준 입력(stdin)을 활성화 컨테이너와 연결(attach)되어 있지 않더라도 표준 입력을 유지합니다. 보통 이 옵션을 사용하여 Bash에 명령을 입력합니다. -t(Pseudo-tty) TTY 모드 Bash Shell 사용하려면 필요한 옵션 이 옵션을 설정하지 않으면 명령을 입력할 수는 있지만 셸이 표시되지 않습니다. -d (detached) 데몬 모드 컨테이너가 백그라운드로 동작 된다 -p (port) 컨테이너 포트 포워딩 [HOST_PORT] : [CONTAINER_PORT] --name 컨테이너의 이름을 지정 /bin/bash 쉘을 이용하여 입출력을 할 수 있다. 컨테이너 목록 (ls) $ docker container ls [option] # running $ docker container ls --all # all $ docker container ls -aq # all and quite mode 컨테이너 기동 (start) $ docker start CONTAINER 컨테이너 재시작 (restart) $ docker restart CONTAINER 컨테이너 접속 (attach) $ docker attach CONTAINER 컨테이너 내부 명령 실행 (exec) $ docker exec CONTAINER COMMAND [ARG...] Docker 를 컨테이너로 진입 후 exit 명령어로 컨테이너를 빠져 나오면 컨테이너가 종료되기 때문에 이에 대해 사용한다. $ docker exec -it CONTAINER /bin/bash CONTAINER 이름을 가진 컨테이너에 /bin/bash 쉘을 사용한다.exit 명령어로 Shell (컨테이너) 을 빠져 나와도 컨테이너가 종료되지 않는다. 컨테이너 삭제 (rm) $ docker rm CONTAINER 컨테이너 파일 복사 (cp) 컨테이너 -> 호스트 $ docker cp CONTAINER:CONTAINER_FILE_PATH HOST_FILE_PATH 호스트 -> 컨테이너 $ docker cp HOST_FILE_PATH CONTAINER:CONTAINER_FILE_PATH $ docker cp ubuntu:/etc/nginx/nginx.conf ./ ubuntu 내에 있는 nginx.conf 파일을 지정된 로컬 호스트 경로로 복사한다. "},"03.-back-end/06.-devops/kubernetes.html":{"url":"03.-back-end/06.-devops/kubernetes.html","title":"Kubernetes","keywords":"","body":"Kubernetes "},"03.-back-end/06.-devops/git.html":{"url":"03.-back-end/06.-devops/git.html","title":"Git","keywords":"","body":"Git ssh-keygen $ ssh-keygen -t rsa -b 4096 -C \"rrest@icloud.com\" Generating public/private rsa key pair. Enter file in which to save the key (/Users/rrest/.ssh/id_rsa): /Users/rrest/.ssh/id_rsa already exists. Overwrite (y/n)? y Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /Users/rrest/.ssh/id_rsa. Your public key has been saved in /Users/rrest/.ssh/id_rsa.pub. The key fingerprint is: SHA256:1iaYasPL6u/8cJY06MnhX7Z2J45cr4nz673wT8cnI20 rrest@icloud.com The key's randomart image is: +---[RSA 4096]----+ | | | | | | | . o . | | o = S o | | = = + o . . | | @ + o o . E +| | + B +o=o*.+ +.| | .o+*.o.=*B==o. | +----[SHA256]-----+ ~/.ssh 경로에 다음 파일이 생성된다. id_rsa 개인키 (지정 경로 ~/.ssh 에 보관) id_rsa.pub 공개키 (복사해서 저장소에 넣음) Parameter -t 암호화 타입 -b 생성할 키의 비트수 (default: 2048) -C 주석입력 Revert Syntax $ git revert {COMMIT_NUMBER} Merge Commit Revert 일반적인 리버트로는 불가능 하다. -m 1 옵션을 넣어 줘야 한다. $ git revert -m 1 {COMMIT_NUMBER} "},"03.-back-end/04.-big-data.html":{"url":"03.-back-end/04.-big-data.html","title":"07. Big Data","keywords":"","body":"07. Big Data 시스템 구성도 데이터처리 패키지 비교 Feature Strom Spark Samza Delivery Semantics At Least Once Exactly-Once with Trident Exactly Once Except in some failure scenarios At Least Once State Management Stateless Roll your own or use Trident Stateful Writes state to storage (HDFS) Stateful Embeded key-value store Latency Sub-Second Seconds Depending on batch size Sub-Second Language Support Any JVM-languages, Ruby, Python, Javascript, Perl Scala, JAVA, Python, R Scala, JAVA JVM-languages only Processing Model one-at-a-time micro-batch / batch one-at-a-time Backpressure O O X Stream Source Spouts Receivers ConSumers Stream Primitive Tuple Dstream Message Stream Computation Bolts Transformations Window operations Tasks 요약 Spark는 Latency 에서 다소 느린 점이 있지만, exactly-once 전송을 제공하고 다양한 워크로드 컴포넌트를 제공한다. Storm은 Latency 에서 유리하지만, Trident를 적용해야 exactly-once 전송을 제공하며 상태관리기능도 Trident를 통해서 적용하거나 자체개발을 해야 한다. Samza는 Latency 에서 유리하지만, 아직 마이너버전이고 At Least Once 전송만을 제공하고 있다. 검색 패키지 비교 Feature Solr Elastic Search Community & Developers Apache Software Foundation and community support Single commercial entity and its employees Node Discovery Apache Zookeeper, mature and battle-tested in a large number of projects Zen, built into Elasticsearch itself, requires dedicated master nodes to be split brain proof Shard Placement Static in nature, requires manual work to migrate shards, starting from Solr 7 – Autoscaling API allows for some dynamic actions Dynamic, shards can be moved on demand depending on the cluster state Caches Global, invalidated with each segment change Per segment, better for dynamically changing data Analytics Engine Facets and powerful streaming aggregations Sophisticated and highly flexible aggregations Optimized Query Execution Currently none Faster range queries depending on the context Search Speed Best for static data, because of caches and uninverted reader Very good for rapidly changing data, because of per-segment caches Analysis Engine Performance Great for static data with exact calculations Exactness of the results depends on data placement Full Text Search Features Language analysis based on Lucene, multiple suggesters, spell checkers, rich highlighting support Language analysis based on Lucene, single suggest API implementation, highlighting rescoring DevOps Friendliness Not fully there yet, but coming Very good APIs Non-flat Data Handling Nested documents and parent-child support Natural support with nested and object types allowing for virtually endless nesting and parent-child support Query DSL JSON (limited), XML (limited) or URL parameters JSON Index/Collection Leader Control Leader placement control and leader rebalancing possibility to even the load on the nodes Not possible Join Currently none Parent_type/Children_type Machine Learning Built-in – on top of streaming aggregations focused on logistic regression and learning to rank contrib module Commercial feature, focused on anomalies and outliers and time-series data Ecosystem Modest – Banana, Zeppelin with community support Rich – Kibana, Grafana, with large entities support and big user base RDBMS Ingestion dataimportHandler logstash 데이터 수집 패키지 비교 Feature Flume Fluentd Log Stash Sqoop 언어 Java Ruby Ruby & Java Java 입력 Avro Source Dummy Input Beats Input FTP Connector Exec Source Exec Input Elastic Search Input Hbase Connector HTTP Source Forward Input Exec Input HDFS Connector JMS Source HTTP Input File Input JDBC Connector Kafka Source Monitor Agent Input HTTP Input Kafka Connector NetCat TCP Source Syslog Input IRC Input Kite Connector NetCat UDP Source Tail Input JDBC Input Scribe Source TCP Input JMS Input Sequence Generator Source UDP Input Kafka Input Spooling Directory Source Windows Eventlog Input Log4J Input Stress Source Source Pipe Input Syslog Source Rabbit MQ Input Taildir Source Redis Input Thrift Source S3 Input Twitter 1% firehose Source Stdin Input STOMP Input Syslog Input TCP Input UDP Input XMPP Input 출력 Avro Sink Copy Output CSV Output Accumulo Connector Elastic Search Sink Elastic Search Output Elastic Search Output FTP Connector File Roll Sink Exec Filter Output Email Output HBase Connector HBase Sink Exec Output Exec Output HDFS Connector HDFS Sink File Output File Output HIVE Connector Hive Sink Forward Output HTTP Output JDBC Connector HTTP Sink Mongo Output InfluxDB Output Kafka Connector IRC Sink Mongo Replset Output IRC Output Kate Connector Kafka Sink Null Option Kafka Output Kite Dataset Sink Relabel Ouput Mongo DB Output Logger Sink Rewrite Tag Filter Output Nagios Output MorphlineSolr Sink Round Robin Output Open TSDB Output Null Sink S3 Output Pipi Output Thrift Sink Stdout Output Rabbit MQ Output WebHDFS Output Redis Output S3 Output Solr Http Output Stdout Output STOMP Output Syslog Output TCP Output UDP Output Web HDFS Output XMPP Output 버퍼 Memory Channel Memory Buffer Memory Queue JDBC Channel File Buffer Presistent Queue Kafka Channel File Channel Spillable Memory Channel Pseudo Transaction Channel 구성 Single Multi-Agent Flow Consolidation Multiplexing 메세지 전송 패키지 비교 Feature Kafka Rabbit MQ 클라이언트 C / C++ Clojure Python Erlang Go (AKA golang) Haskell Erlang Perl .Net Scala Clojure Java Ruby Python Node JS Ruby Proxy (HTTP REST, etc) PHP Perl Swift Stdin / Stdout .Net (C#) PHP Objective-C Rust JS Alternative Java Go Storm Elixir Scala DSL Swift 기본 메시징 처리 방식 Topic 방식 (발행 - 구독) Queue 방식 (발생 - 소비) Consumer Group 설정해서 Queue 방식 사용 MQTT 를 통해서 Topic 방식 사용 클라이언트 동작 Client Pull Server Push 지원 프로토콜 TCP AMQP MQTT STOMP 저장소 파일 메모리 / 파일 요약 Kafka는 IO 방식과 프로토콜의 오버 헤드가 적어 스트리밍 형태의 데이터 전송에 적합 Rabbbit MQ는 표준 프로토콜을 제공하고 큐에 데이터가 유입되면 이벤트가 발행해서 클라이언트에 데이터를 전달하는 이벤트 처리에 적합 하다. "}}